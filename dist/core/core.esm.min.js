/*
* IntersectionTrigger v1.0.1 
* IntersectionTrigger utilizes the most modern web technology to trigger anything by intersection. Including scroll-based animations.
* https://sunshine-themes.com/?appID=ss_app_1
*
* Copyright 2022, Sunshine. All rights reserved.
* @license: Released under the personal 'no charge' license can be viewed at http://sunshine-themes.com/?appID=ss_app_1&tab=license, Licensees of commercial or business license are granted additional rights. See http://sunshine-themes.com/?appID=ss_app_1&tab=license for details..
* @author: Sherif Magdy, sherifmagdy@sunshine-themes.com
*
* Released on: December 20, 2022
*/

var P=()=>{};var B={defaults:{enter:"0%",leave:"100%",once:!1,onEnter:P,onLeave:P,onEnterBack:P,onLeaveBack:P,toggleClass:null,animation:null},rootEnter:"100%",rootLeave:"0%",axis:"y",name:"",root:null,guides:!1,onScroll:P},O={hasEntered:!1,hasEnteredBack:!1,hasLeft:!0,hasLeftBack:!0,hasEnteredOnce:!1,onScroll:{backup:null,animate:null},ids:{snapTimeOutId:0}};var g={function:i=>typeof i=="function",string:i=>typeof i=="string",boolean:i=>typeof i=="boolean",object:i=>i&&typeof i=="object"&&!(i instanceof Array),inObject:(i,t)=>g.object(i)&&t in i,num:i=>typeof i=="number",percent:i=>i&&i.includes("%"),pixel:i=>i&&i.includes("px"),array:i=>i instanceof Array,element:i=>i instanceof HTMLElement||i instanceof Element,doc:i=>i&&i.nodeType===9,scrollable:(i,t=null)=>t?t==="y"?i.scrollHeight>i.clientHeight:i.scrollWidth>i.clientWidth:i.scrollHeight>i.clientHeight||i.scrollWidth>i.clientWidth,anime:i=>g.object(i)&&i.hasOwnProperty("animatables")&&!i.hasOwnProperty("add"),tl:i=>g.object(i)&&i.hasOwnProperty("add")&&g.function(i.add),animeInstance:i=>g.anime(i)||g.tl(i)};var I=(i,t)=>i&&i.getBoundingClientRect()[t],M=(i,t)=>t==="y"?i.scrollHeight:i.scrollWidth,k=(i,t)=>{g.string(i)&&(i=parseFloat(i));let s=Math.pow(10,t||0);return Math.round(i*s)/s};var L=(i,t)=>{let s=i,e=t;return Object.entries(s).forEach(([r,o])=>{g.object(o)?L(o,e[r]=e[r]||{}):r in e||(e[r]=o)}),e},p=i=>{throw new Error(i)},x=(i,t)=>[i,t].sort((s,e)=>s-e),R=i=>{let t=/^(-?\d*\.?\d+)(px|%)$/.exec(i);return{value:parseFloat(t[1]),unit:t[2]}},H=i=>i.split(/\s+/).map(t=>R(t));var D=class{constructor(t){return this._it=t,this.setUtils(),this}setUtils(){this.isVertical=()=>this._it.axis==="y",this.isViewport=()=>!this._it._root,this.getRoot=()=>this._it._root??window,this.dirProps=()=>this.isVertical()?{ref:"top",length:"height",refOpposite:"bottom",clientLength:document.documentElement.clientHeight}:{ref:"left",length:"width",refOpposite:"right",clientLength:document.documentElement.clientWidth},this.setRootMargin=(t,s)=>{let{length:e,clientLength:r}=this.dirProps(),o=this._it._root?I(this._it._root,e):r,a=(c,h)=>{let{value:d,unit:f,normal:v}=c;if(f==="%")return v*h;if(f==="px")return d};t.pixeled=a(t,o),s.pixeled=a(s,o),this._it._isREPGreater=t.pixeled>=s.pixeled;let n={};n.fromOppRef=`${(this._it._isREPGreater?t.pixeled:s.pixeled)-o}px`,n.fromRef=`${-1*(this._it._isREPGreater?s.pixeled:t.pixeled)}px`;let l=M(this.isViewport()?document.body:this._it._root,this.isVertical()?"x":"y");return this.isVertical()?`${n.fromRef} ${l}px ${n.fromOppRef} ${l}px`:`${l}px ${n.fromOppRef} ${l}px ${n.fromRef}`},this.setThreshold=()=>{let{enter:t,leave:s,maxPosition:e}=this._it._defaultTriggerParams,r=[0,t,s,k(1-e,2),1];return this._it.triggers.forEach(o=>{let{enter:a,leave:n,maxPosition:l}=this.getTriggerData(o);r.push(a,n,k(1-l,2))}),[...new Set(r)]},this.parseQuery=(t,s)=>{switch(!0){case g.string(t):return[...document.querySelectorAll(t)];case g.array(t):return t;case g.element(t):return[t];default:p(`${s} parameter must be a valid selector, an element or array of elements`)}},this.customParseQuery=(t,s="trigger")=>{let e=s==="trigger",r=e?[]:{};return e?this.parseQuery(t,"trigger"):(r=g.string(t)?document.querySelector(t):g.element(t)?t:p("root parameter must be a valid selector or an element"),r)},this.validatePosition=t=>(g.function(t)&&(t=t(this._it)),g.string(t)||p("enter, leave, rootEnter and rootLeave parameters must be a string."),t),this.setPositionData=t=>{t=this.validatePosition(t);let s=t.trim(),e=R(s),r=k(e.value);return{original:s,unit:e.unit,value:r,normal:e.unit==="%"?r/100:null}},this.parsePositions=(t,s,e,r)=>{let o=[t,e,s,r].map(a=>this.setPositionData(this.validatePosition(a).trim()));return{tEP:o[0],rEP:o[1],tLP:o[2],rLP:o[3]}},this.deleteTriggerData=t=>{this._it._triggersData.delete(t)},this.hasTriggerData=(t,s=null)=>{let e=this._it._triggersData.has(t);return s?e&&s in this.getTriggerData(t):e},this.getTriggerData=(t,s=null)=>s?this.hasTriggerData(t,s)?this._it._triggersData.get(t)[s]:{}:this.hasTriggerData(t)&&this._it._triggersData.get(t)||{},this.setTriggerData=(t,s,e=null)=>{if(e){let r=this.getTriggerData(t);g.object(r)&&this._it._triggersData.set(t,{...r,...e});return}this._it._triggersData.set(t,s)},this.getTriggerStates=(t,s=null)=>{let e=this.getTriggerData(t,"states"),r=e.hasEntered||e.hasEnteredBack;return s?e[s]:{...e,hasEnteredFromOneSide:r}},this.setTriggerStates=(t,s={})=>{let e=this.getTriggerData(t),r=e&&{...e.states,...s};this.setTriggerData(t,null,{states:r})},this.setTriggerScrollStates=(t,s,e=null)=>{let r=this.getTriggerStates(t,"onScroll");if(r[s]=e,this.setTriggerStates(t,{onscroll:{...r}}),e){this._it._states.runningScrollCbs===0&&this._it.addScrollListener(this._it._onScrollHandler),this._it._states.runningScrollCbs++;return}0<this._it._states.runningScrollCbs&&this._it._states.runningScrollCbs--,this._it._states.runningScrollCbs===0&&this._it.removeScrollListener(this._it._onScrollHandler)},this.onTriggerEnter=(t,s="Enter")=>{let{hasEnteredOnce:e}=this.getTriggerStates(t),{onEnter:r,onEnterBack:o,toggleClass:a,animation:n}=this.getTriggerData(t),l=s==="Enter",c={callback:l?r:o,enterProp:l?"hasEntered":"hasEnteredBack",leaveProp:l?"hasLeftBack":"hasLeft",eventIndex:l?0:2};if(c.callback(t,this._it),this._it.killed)return this.kill();a&&this._it.toggleClass.toggle(t,a,c.eventIndex),n&&this._it.animation.animate(t,n,c.eventIndex);let h=e?{[c.enterProp]:!0,[c.leaveProp]:!1}:{[c.enterProp]:!0,hasLeft:!1,hasLeftBack:!1};this.setTriggerStates(t,h),e||this.setTriggerStates(t,{hasEnteredOnce:!0})},this.onTriggerLeave=(t,s="Leave")=>{let{once:e}=this.getTriggerData(t),{hasEnteredOnce:r}=this.getTriggerStates(t),{onLeave:o,onLeaveBack:a,toggleClass:n,animation:l}=this.getTriggerData(t),c=s==="Leave",h={callback:c?o:a,leaveProp:c?"hasLeft":"hasLeftBack",eventIndex:c?1:3};if(h.callback(t,this._it),this._it.killed)return this.kill();l&&this._it.animation.animate(t,l,h.eventIndex),n&&this._it.toggleClass.toggle(t,n,h.eventIndex),this.setTriggerStates(t,{[h.leaveProp]:!0,hasEntered:!1,hasEnteredBack:!1}),e&&r&&this._it.remove(t)},this.getPositions=(t,s,{enter:e,leave:r,ref:o,refOpposite:a,length:n})=>{let l=this._it._isREPGreater;return[t[o]+e*t[n],t[o]+r*t[n],l?s[a]:s[o],l?s[o]:s[a]]},this.toggleActions=t=>{let s=t.getBoundingClientRect();this._it.rootBounds=this.getRootRect(this._it.observer.rootMargin);let e=this._it.rootBounds,{hasEnteredFromOneSide:r,hasLeft:o,hasLeftBack:a,hasEnteredOnce:n}=this.getTriggerStates(t),{enter:l,leave:c}=this.getTriggerData(t),{ref:h,refOpposite:d,length:f}=this.dirProps(),[v,b,S,E]=this.getPositions(s,e,{enter:l,leave:c,ref:h,refOpposite:d,length:f}),_=!0;switch(!0){case(a&&S>v):this.onTriggerEnter(t);break;case(r&&E>b):this.onTriggerLeave(t);break;case(o&&n&&E<b):this.onTriggerEnter(t,"EnterBack");break;case(r&&S<v):this.onTriggerLeave(t,"hasLeftBack");break;default:_=!1;break}return _},this.parseRootMargin=t=>{var s=t||"0px",e=H(s);return e[1]=e[1]||e[0],e[2]=e[2]||e[0],e[3]=e[3]||e[1],e},this.expandRectByRootMargin=(t,s)=>{let e=this.parseRootMargin(s).map((o,a)=>o.unit=="px"?o.value:o.value*(a%2?t.width:t.height)/100),r={top:t.top-e[0],right:t.right+e[1],bottom:t.bottom+e[2],left:t.left-e[3]};return r.width=r.right-r.left,r.height=r.bottom-r.top,r},this.getRootRect=t=>{let s;if(this._it._root&&!g.doc(this._it._root))return s=this._it._root.getBoundingClientRect(),this.expandRectByRootMargin(s,t);let e=g.doc(this._it._root)?this._it._root:document,r=e.documentElement,o=e.body;return s={top:0,left:0,right:r.clientWidth||o.clientWidth,width:r.clientWidth||o.clientWidth,bottom:r.clientHeight||o.clientHeight,height:r.clientHeight||o.clientHeight},this.expandRectByRootMargin(s,t)}}kill(){this._it=null}},A=D;var F=[],m=[],V=0,u=class{constructor(t={}){this._userOptions=t,this.triggers=[],this._triggersData=new WeakMap,this._utils=new A(this),this.id=V,V++,m.push(this),this.animation=null,this.toggleClass=null,this.guides=null,this._setStates(),this._setInstance()}_setPlugin(t){let e=u.getRegisteredPlugins().find(r=>t===r.pluginName);e&&(this[t]=new e(this))}_addResizeListener(){this._removeResizeListener(),this._onResizeHandler=()=>this.update(),this._utils.getRoot().addEventListener("resize",this._onResizeHandler,!1)}_removeResizeListener(){this._utils.getRoot().removeEventListener("resize",this._onResizeHandler,!1)}_setStates(){this._states={},this._states.oCbFirstInvoke=!0,this._states.runningScrollCbs=0}_rAFCallback=t=>{this.triggers.forEach(s=>{let e=this._utils.getTriggerStates(s,"onScroll");for(let r in e)e[r]&&g.function(e[r])&&e[r](s,t)})};_onScrollHandler=()=>this._rAFID=requestAnimationFrame(this._rAFCallback);addScrollListener(t){this._utils.getRoot().addEventListener("scroll",t,!1)}removeScrollListener(t){this._utils.getRoot().removeEventListener("scroll",t,!1)}_observerCallback=(t,s)=>{let{ref:e,refOpposite:r,length:o}=this._utils.dirProps();for(let a of t){let n=a.target,l=a.boundingClientRect,c=a.isIntersecting;this.rootBounds=a.rootBounds||this._utils.getRootRect(s.rootMargin);let h=this.rootBounds,d=h[o],{enter:f,leave:v}=this._utils.getTriggerData(n),{hasEnteredFromOneSide:b,onScroll:{backup:S}}=this._utils.getTriggerStates(n),[E,_,C,T]=this._utils.getPositions(l,h,{enter:f,leave:v,ref:e,refOpposite:r,length:o}),y=l[o]>=d,w=!!S;switch(!0){case this._states.oCbFirstInvoke:switch(!0){case(!c&&T>_):this._utils.onTriggerEnter(n),this._utils.onTriggerLeave(n);break;case c:switch(!0){case(C>E&&T<_):this._utils.onTriggerEnter(n);break;case T>_:this._utils.onTriggerEnter(n),this._utils.onTriggerLeave(n);break}y&&this._utils.setTriggerScrollStates(n,"backup",this._utils.toggleActions);break}break;case!c:switch(w&&this._utils.setTriggerScrollStates(n,"backup",null),!0){case(b&&T>_):this._utils.onTriggerLeave(n);break;case(b&&C<E):this._utils.onTriggerLeave(n,"onLeaveBack");break}break;case(c&&!w):this._utils.toggleActions(n),y&&this._utils.setTriggerScrollStates(n,"backup",this._utils.toggleActions);break}}this._states.oCbFirstInvoke=!1};_createInstance(){this._rootMargin=this._utils.setRootMargin(this._positionsData.rEP,this._positionsData.rLP),this._threshold=this._utils.setThreshold(),this._observerOptions={root:this._root,rootMargin:this._rootMargin,threshold:this._threshold},this.observer=new IntersectionObserver(this._observerCallback,this._observerOptions),this._root=this.observer.root,this.rootBounds=this._utils.getRootRect(this.observer.rootMargin),this._isViewport=this._utils.isViewport()}_setInstance(){this._defaultOptions=B,this._options=L(this._defaultOptions,this._userOptions),this.axis=g.string(this._options.axis)?this._options.axis:p("axis parameter must be a string."),this.name=g.string(this._options.name)?this._options.name:p("name parameter must be a string."),this._root=!!this._options.root&&this._utils.customParseQuery(this._options.root,"root")||null,this._positionsData=this._utils.parsePositions(this._options.defaults.enter,this._options.defaults.leave,this._options.rootEnter,this._options.rootLeave),this.customScrollHandler=this._options.onScroll;let{once:t,onEnter:s,onLeave:e,onEnterBack:r,onLeaveBack:o,toggleClass:a,animation:n}=this._options.defaults,l=this._positionsData.tEP.normal,c=this._positionsData.tLP.normal,[h,d]=x(l,c);return this._defaultTriggerParams={enter:l,leave:c,minPosition:h,maxPosition:d,once:t,onEnter:s,onLeave:e,onEnterBack:r,onLeaveBack:o,toggleClass:a,animation:n},this._createInstance(),this._addResizeListener(),this.customScrollHandler&&this.addScrollListener(this.customScrollHandler),this._options.guides&&(this._setPlugin("guides"),this.guides.init(this._options.guides)),this}add(t={},s={}){let e=this._utils.customParseQuery(t);"enter"in s&&(s.enter=this._utils.setPositionData(s.enter).normal),"leave"in s&&(s.leave=this._utils.setPositionData(s.leave).normal);let r=L(this._defaultTriggerParams,s),[o,a]=x(r.enter,r.leave),n={...r,minPosition:o,maxPosition:a,states:{...O}},l=h=>{!this[h]&&this._setPlugin(h),n[h]=this[h].parse(n[h])};n.toggleClass&&l("toggleClass"),n.animation&&l("animation"),this.triggers=[...new Set([...this.triggers,...e])];let c=!1;return[s.enter,s.leave].forEach(h=>!this._threshold.some(d=>h===d)&&(c=!0)),c?(e.forEach(h=>this._utils.setTriggerData(h,n)),this.update()):e.forEach(h=>{this._utils.setTriggerData(h,n),this.observer.observe(h)}),this.guides&&this.guides.update(),this}remove(t={}){let s=this._utils.customParseQuery(t);s.forEach(r=>{this._utils.deleteTriggerData(r),this.observer.unobserve(r)});let e=this.triggers.filter(r=>!s.some(a=>r===a));return this.triggers=e,this.guides&&this.guides.update(),this}_disconnect(){this.observer&&this.observer.disconnect(),this.observer=null}update(){this._disconnect(),this._createInstance(),this.triggers.forEach(t=>this.observer.observe(t)),this.guides&&this.guides.update()}kill(){this.killed=!0,this._disconnect(),this.removeScrollListener(this._onScrollHandler),this.removeScrollListener(this.customScrollHandler),this._removeResizeListener(),this._rAFID&&cancelAnimationFrame(this._rAFID),this.guides&&this.guides.kill(),this.toggleClasss&&this.toggleClasss.kill(),this.animation&&this.animation.kill(),this.triggers=[],this.animation=this.toggleClass=this.guides=this._utils=null;let t=m.indexOf(this);~t&&m.splice(t,1)}};u.getInstances=()=>m;u.getInstanceById=i=>m.find(t=>t.id===i);u.update=()=>m.forEach(i=>i.update());u.kill=()=>m.forEach(i=>i.kill());u.registerPlugins=(i=[])=>F.push(...i);u.getRegisteredPlugins=()=>F;var U=u;export{U as default};
//# sourceMappingURL=core.esm.min.js.map
