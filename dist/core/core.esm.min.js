/*
* IntersectionTrigger v1.0.4 
* IntersectionTrigger utilizes the most modern web technology to trigger anything by intersection. Including scroll-based animations.
* https://sunshine-themes.com/?appID=ss_app_1
*
* Copyright 2023, Sunshine. All rights reserved.
* @license: Released under the personal 'no charge' license can be viewed at http://sunshine-themes.com/?appID=ss_app_1&tab=license, Licensees of commercial or business license are granted additional rights. See http://sunshine-themes.com/?appID=ss_app_1&tab=license for details..
* @author: Sherif Magdy, sherifmagdy@sunshine-themes.com
*
* Released on: February 8, 2023
*/

var D=()=>{};var y={defaults:{enter:"0%",leave:"100%",once:!1,onEnter:D,onLeave:D,onEnterBack:D,onLeaveBack:D,toggleClass:void 0,animation:void 0},rootEnter:"100%",rootLeave:"0%",axis:"y",name:"",root:null,guides:!1,onScroll:D};var x={hasEntered:!1,hasEnteredBack:!1,hasLeft:!0,hasLeftBack:!0,hasEnteredOnce:!1,onScroll:{backup:void 0,animate:void 0},ids:{snapTimeOutId:0}};var u={function:i=>typeof i=="function",string:i=>typeof i=="string",boolean:i=>typeof i=="boolean",object:i=>!!i&&typeof i=="object"&&i!==null&&!(i instanceof Array),num:i=>typeof i=="number",array:i=>i instanceof Array,element:i=>i instanceof HTMLElement,empty:i=>Object.keys(i).length===0,doc:i=>u.element(i)&&i.nodeType===9,anime:i=>u.object(i)&&i.hasOwnProperty("animatables")&&!i.hasOwnProperty("add"),tl:i=>u.object(i)&&i.hasOwnProperty("add")&&u.function(i.add),animeInstance:i=>u.anime(i)||u.tl(i),pixel:i=>i.includes("px"),inObject:(i,t)=>u.object(i)&&t in i,percent:i=>i.includes("%"),scrollable:(i,t)=>t?t==="y"?i.scrollHeight>i.clientHeight:i.scrollWidth>i.clientWidth:i.scrollHeight>i.clientHeight||i.scrollWidth>i.clientWidth};var I=(i,t)=>i&&i.getBoundingClientRect()[t],H=(i,t)=>t==="y"?i.scrollHeight:i.scrollWidth,k=(i,t)=>{u.string(i)&&(i=parseFloat(i));let e=Math.pow(10,t||0);return Math.round(i*e)/e};var S=(i,t)=>{let e={...i};for(let[n,s]of Object.entries(t))if(u.object(e[n])&&!u.empty(e[n])){if(!u.object(s))continue;e[n]=S(e[n],s)}else e[n]=s;return e},E=i=>{throw new Error(i)},O=(i,t)=>[i,t].sort((e,n)=>e-n),L=i=>{let t={value:0,unit:""},e=/^(-?\d*\.?\d+)(px|%)$/.exec(i);return e&&(t={value:parseFloat(e[1]),unit:e[2]}),t},w=i=>i.split(/\s+/).map(t=>L(t));var R=class{constructor(t){return this._it=t,this.setUtils(),this}setUtils(){this.isVertical=()=>this._it.axis==="y",this.getRoot=t=>this._it._root?this._it._root:t==="resize"?window:t==="scroll"?document:document.documentElement,this.dirProps=()=>this.isVertical()?{ref:"top",length:"height",refOpposite:"bottom",clientLength:document.documentElement.clientHeight}:{ref:"left",length:"width",refOpposite:"right",clientLength:document.documentElement.clientWidth},this.setRootMargin=(t,e)=>{let{length:n,clientLength:s}=this.dirProps(),r=this._it._root?I(this._it._root,n):s,a=(g,h)=>{let{value:f,unit:p,normal:d}=g;return p==="%"?d*h:f};t.pixeled=a(t,r),e.pixeled=a(e,r),this._it._isREPGreater=t.pixeled>=e.pixeled;let o={fromRef:`${-1*(this._it._isREPGreater?e.pixeled:t.pixeled)}px`,fromOppRef:`${(this._it._isREPGreater?t.pixeled:e.pixeled)-r}px`},l=H(this.getRoot(),this.isVertical()?"x":"y");return this.isVertical()?`${o.fromRef} ${l}px ${o.fromOppRef} ${l}px`:`${l}px ${o.fromOppRef} ${l}px ${o.fromRef}`},this.setThreshold=()=>{let t=[0,1];return this._it.triggers.forEach(e=>{let{enter:n,leave:s,maxPosition:r}=this.getTriggerData(e);t.push(n,s,k(1-r,2))}),[...new Set(t)]},this.parseQuery=(t,e="trigger")=>u.string(t)?[...document.querySelectorAll(t)]:u.array(t)?t:u.element(t)?[t]:E(`${e} parameter must be a valid selector, an element or array of elements`),this.parseRoot=t=>{if(!t)return null;if(u.string(t)){let e=document.querySelector(t);return e||E("root parameter must be a valid selector")}return u.element(t)?t:E("root parameter must be an element")},this.validatePosition=t=>(u.function(t)&&(t=t(this._it)),u.string(t)?t:E("enter, leave, rootEnter and rootLeave parameters must be a string.")),this.setPositionData=t=>{t=this.validatePosition(t);let e=t.trim(),n=L(e),s=k(n.value);return{original:e,unit:n.unit,value:s,normal:n.unit==="%"?s/100:0}},this.parsePositions=(t,e,n,s)=>{let r=[t,n,e,s].map(a=>this.setPositionData(this.validatePosition(a).trim()));return{tEP:r[0],rEP:r[1],tLP:r[2],rLP:r[3]}},this.deleteTriggerData=t=>{this._it._triggersData.delete(t)},this.hasTriggerData=(t,e)=>{let n=this._it._triggersData.has(t);return e?n&&e in this.getTriggerData(t):n},this.getTriggerData=(t,e)=>e?this.hasTriggerData(t,e)?this._it._triggersData.get(t)[e]:{}:this.hasTriggerData(t)&&this._it._triggersData.get(t)||{},this.setTriggerData=(t,e,n)=>{if(n){let s=this.getTriggerData(t);"enter"in s&&this._it._triggersData.set(t,{...s,...e});return}this._it._triggersData.set(t,e)},this.getTriggerStates=(t,e)=>{let n=this.getTriggerData(t,"states");return e?n[e]:{...n,hasEnteredFromOneSide:n.hasEntered||n.hasEnteredBack}},this.setTriggerStates=(t,e)=>{let n=this.getTriggerData(t),s=n&&{...n.states,...e};this.setTriggerData(t,{states:s},!0)},this.setTriggerScrollStates=(t,e,n)=>{let s=this.getTriggerStates(t,"onScroll");if(s[e]=n,this.setTriggerStates(t,{onScroll:{...s}}),n){this._it._states.runningScrollCbs===0&&this._it.addScrollListener(this._it._onScrollHandler),this._it._states.runningScrollCbs++;return}0<this._it._states.runningScrollCbs&&this._it._states.runningScrollCbs--,this._it._states.runningScrollCbs===0&&this._it.removeScrollListener(this._it._onScrollHandler)},this.onTriggerEnter=(t,e="Enter")=>{let{hasEnteredOnce:n}=this.getTriggerStates(t),{onEnter:s,onEnterBack:r,toggleClass:a,animation:o}=this.getTriggerData(t),l=e==="Enter",g={callback:l?s:r,enterProp:l?"hasEntered":"hasEnteredBack",leaveProp:l?"hasLeftBack":"hasLeft",eventIndex:l?0:2};if(g.callback(t,this._it),this._it.killed)return this.kill();a&&this._it.toggleClass.toggle(t,a,g.eventIndex),o&&this._it.animation.animate(t,o,g.eventIndex);let h=n?{[g.enterProp]:!0,[g.leaveProp]:!1}:{[g.enterProp]:!0,hasLeft:!1,hasLeftBack:!1};this.setTriggerStates(t,h),n||this.setTriggerStates(t,{hasEnteredOnce:!0})},this.onTriggerLeave=(t,e="Leave")=>{let{once:n}=this.getTriggerData(t),{hasEnteredOnce:s}=this.getTriggerStates(t),{onLeave:r,onLeaveBack:a,toggleClass:o,animation:l}=this.getTriggerData(t),g=e==="Leave",h={callback:g?r:a,leaveProp:g?"hasLeft":"hasLeftBack",eventIndex:g?1:3};if(h.callback(t,this._it),this._it.killed)return this.kill();o&&this._it.toggleClass.toggle(t,o,h.eventIndex),l&&this._it.animation.animate(t,l,h.eventIndex),this.setTriggerStates(t,{[h.leaveProp]:!0,hasEntered:!1,hasEnteredBack:!1}),n&&s&&this._it.remove(t)},this.getPositions=(t,e,{enter:n,leave:s,ref:r,refOpposite:a,length:o})=>{let l=this._it._isREPGreater;return[t[r]+n*t[o],t[r]+s*t[o],l?e[a]:e[r],l?e[r]:e[a]]},this.toggleActions=t=>{let e=t.getBoundingClientRect();this._it.rootBounds=this.getRootRect(this._it.observer.rootMargin);let n=this._it.rootBounds,{hasEnteredFromOneSide:s,hasLeft:r,hasLeftBack:a,hasEnteredOnce:o}=this.getTriggerStates(t),{enter:l,leave:g}=this.getTriggerData(t),{ref:h,refOpposite:f,length:p}=this.dirProps(),[d,b,v,T]=this.getPositions(e,n,{enter:l,leave:g,ref:h,refOpposite:f,length:p}),c=!0;switch(!0){case(a&&v>d):this.onTriggerEnter(t);break;case(s&&T>b):this.onTriggerLeave(t);break;case(r&&o&&T<b):this.onTriggerEnter(t,"EnterBack");break;case(s&&v<d):this.onTriggerLeave(t,"hasLeftBack");break;default:c=!1;break}return c},this.parseRootMargin=t=>{var e=t||"0px",n=w(e);return n[1]=n[1]||n[0],n[2]=n[2]||n[0],n[3]=n[3]||n[1],n},this.expandRectByRootMargin=(t,e)=>{let n=this.parseRootMargin(e).map((r,a)=>r.unit==="px"?r.value:r.value*(a%2?t.width:t.height)/100),s={top:t.top-n[0],right:t.right+n[1],bottom:t.bottom+n[2],left:t.left-n[3],width:0,height:0};return s.width=s.right-s.left,s.height=s.bottom-s.top,s},this.getRootRect=t=>{let e;if(this._it._root&&!u.doc(this._it._root))return e=this._it._root.getBoundingClientRect(),this.expandRectByRootMargin(e,t);let n=u.doc(this._it._root)?this._it._root:document,s=n.documentElement,r=n.body;return e={top:0,left:0,right:s.clientWidth||r.clientWidth,width:s.clientWidth||r.clientWidth,bottom:s.clientHeight||r.clientHeight,height:s.clientHeight||r.clientHeight},this.expandRectByRootMargin(e,t)}}kill(){this._it=void 0}},B=R;var F=[],_=[],$=0,m=class{constructor(t={}){this._rAFCallback=t=>{this.triggers.forEach(e=>{let n=this._utils.getTriggerStates(e,"onScroll");for(let s in n)n[s]&&n[s](e,t)})};this._onScrollHandler=()=>this._rAFID=requestAnimationFrame(this._rAFCallback);this._observerCallback=(t,e)=>{let{ref:n,refOpposite:s,length:r}=this._utils.dirProps();for(let a of t){let o=a.target,l=a.boundingClientRect,g=a.isIntersecting;this.rootBounds=a.rootBounds||this._utils.getRootRect(e.rootMargin);let h=this.rootBounds,f=h[r],{enter:p,leave:d}=this._utils.getTriggerData(o);console.log(this._utils.getTriggerData(o));let{hasEnteredFromOneSide:b,onScroll:{backup:v}}=this._utils.getTriggerStates(o),[T,c,P,C]=this._utils.getPositions(l,h,{enter:p,leave:d,ref:n,refOpposite:s,length:r}),M=l[r]>=f,A=!!v;switch(!0){case this._states.oCbFirstInvoke:switch(!0){case(!g&&C>c):this._utils.onTriggerEnter(o),this._utils.onTriggerLeave(o);break;case g:switch(!0){case(P>T&&C<c):this._utils.onTriggerEnter(o);break;case C>c:this._utils.onTriggerEnter(o),this._utils.onTriggerLeave(o);break}M&&this._utils.setTriggerScrollStates(o,"backup",this._utils.toggleActions);break}break;case!g:switch(A&&this._utils.setTriggerScrollStates(o,"backup"),!0){case(b&&C>c):this._utils.onTriggerLeave(o);break;case(b&&P<T):this._utils.onTriggerLeave(o,"onLeaveBack");break}break;case(g&&!A):this._utils.toggleActions(o),M&&this._utils.setTriggerScrollStates(o,"backup",this._utils.toggleActions);break}}this._states.oCbFirstInvoke=!1};this._userOptions=t,this.triggers=[],this._triggersData=new WeakMap,this._utils=new B(this),this.id=$,$++,_.push(this),this.animation=void 0,this.toggleClass=void 0,this.guides=void 0,this._states={oCbFirstInvoke:!0,runningScrollCbs:0},this._setInstance()}_setPlugin(t){let n=m.getRegisteredPlugins().find(s=>t===s.pluginName);n&&(this[t]=new n(this))}_addResizeListener(){this._removeResizeListener(),this._onResizeHandler=()=>this.update(),this._utils.getRoot("resize").addEventListener("resize",this._onResizeHandler,!1)}_removeResizeListener(){this._utils.getRoot("resize").removeEventListener("resize",this._onResizeHandler,!1)}addScrollListener(t){this._utils.getRoot("scroll").addEventListener("scroll",t,!1)}removeScrollListener(t){this._utils.getRoot("scroll").removeEventListener("scroll",t,!1)}_createInstance(){this._rootMargin=this._utils.setRootMargin(this._positionsData.rEP,this._positionsData.rLP),this._threshold=this._utils.setThreshold(),this.observer=new IntersectionObserver(this._observerCallback,{root:this._root,rootMargin:this._rootMargin,threshold:this._threshold}),this._root=this.observer.root,this.rootBounds=this._utils.getRootRect(this.observer.rootMargin)}_setInstance(){this._defaultOptions=y,this._options=S(this._defaultOptions,this._userOptions);let{axis:t,name:e,root:n,defaults:{enter:s,leave:r},onScroll:a,rootEnter:o,rootLeave:l,guides:g}=this._options;return this.axis=t,this.name=e,this._root=this._utils.parseRoot(n),this._positionsData=this._utils.parsePositions(s,r,o,l),this.customScrollHandler=a,this._createInstance(),this._addResizeListener(),this.customScrollHandler&&this.addScrollListener(this.customScrollHandler),g&&(this._setPlugin("guides"),this.guides.init(g)),this}add(t,e){let n=this._utils.parseQuery(t),{defaults:s}=this._options,r=e||{},a=(c,P="tEP")=>c?this._utils.setPositionData(c).normal:this._positionsData[P].normal,o=c=>(!this[c]&&this._setPlugin(c),this[c]),l=S(s,r),{enter:g,leave:h,toggleClass:f,animation:p}=l,d={...l,enter:a(g),leave:a(h,"tLP"),toggleClass:f?o("toggleClass").parse(f):void 0,animation:p?o("animation").parse(p):void 0,states:{...x}},[b,v]=O(d.enter,d.leave);d.minPosition=b,d.maxPosition=v,this.triggers=[...new Set([...this.triggers,...n])];let T=!1;return[d.enter,d.leave].forEach(c=>!this._threshold.some(P=>c===P)&&(T=!0)),T?(n.forEach(c=>this._utils.setTriggerData(c,d)),this.update()):n.forEach(c=>{this._utils.setTriggerData(c,d),this.observer.observe(c)}),this.guides&&this.guides.update(),this}remove(t){let e=this._utils.parseQuery(t);e.forEach(s=>{this._utils.deleteTriggerData(s),this.observer.unobserve(s)});let n=this.triggers.filter(s=>!e.some(a=>s===a));return this.triggers=n,this.guides&&this.guides.update(),this}_disconnect(){this.observer&&this.observer.disconnect(),this.observer=void 0}update(){this._disconnect(),this._createInstance(),this.triggers.forEach(t=>this.observer&&this.observer.observe(t)),this.guides&&this.guides.update()}kill(){this.killed=!0,this._disconnect(),this.removeScrollListener(this._onScrollHandler),this.removeScrollListener(this.customScrollHandler),this._removeResizeListener(),this._rAFID&&cancelAnimationFrame(this._rAFID),this.guides&&this.guides.kill(),this.toggleClass&&this.toggleClass.kill(),this.animation&&this.animation.kill(),this.triggers=[],this.animation=this.toggleClass=this.guides=this._utils=void 0;let t=_.indexOf(this);~t&&_.splice(t,1)}};m.getInstances=()=>_;m.getInstanceById=i=>_.find(t=>t.id===i);m.update=()=>_.forEach(i=>i.update());m.kill=()=>_.forEach(i=>i.kill());m.registerPlugins=(i=[])=>F.push(...i);m.getRegisteredPlugins=()=>F;var q=m;export{q as default};
//# sourceMappingURL=core.esm.min.js.map
