/*
* IntersectionTrigger v1.1.1 
* IntersectionTrigger utilizes the most modern web technology to trigger anything by intersection. Including scroll-based animations.
* https://sunshine-themes.com/?appID=ss_app_1
*
* Copyright 2023, Sunshine. All rights reserved.
* @license: Released under the personal 'no charge' license can be viewed at http://sunshine-themes.com/?appID=ss_app_1&tab=license, Licensees of commercial or business license are granted additional rights. See http://sunshine-themes.com/?appID=ss_app_1&tab=license for details..
* @author: Sherif Magdy, sherifmagdy@sunshine-themes.com
*
* Released on: February 22, 2023
*/

var C=Object.defineProperty;var $=e=>C(e,"__esModule",{value:!0});var K=(e,t)=>{for(var i in t)C(e,i,{get:t[i],enumerable:!0})};$(exports);K(exports,{default:()=>V});var P=()=>{};var I={defaults:{enter:"0%",leave:"100%",once:!1,onEnter:P,onLeave:P,onEnterBack:P,onLeaveBack:P,toggleClass:void 0,animation:void 0},rootEnter:"100%",rootLeave:"0%",axis:"y",name:"",root:null,guides:!1,onScroll:P};var H={hasEntered:!1,hasEnteredBack:!1,hasLeft:!0,hasLeftBack:!0,hasEnteredOnce:!1,onScroll:{backup:void 0,animate:void 0},ids:{snapTimeOutId:0}};var g={function:e=>typeof e=="function",string:e=>typeof e=="string",boolean:e=>typeof e=="boolean",object:e=>!!e&&typeof e=="object"&&e!==null&&!(e instanceof Array),num:e=>typeof e=="number",array:e=>e instanceof Array,element:e=>e instanceof HTMLElement,empty:e=>Object.keys(e).length===0,doc:e=>g.element(e)&&e.nodeType===9,anime:e=>g.object(e)&&e.hasOwnProperty("animatables")&&!e.hasOwnProperty("add"),tl:e=>g.object(e)&&e.hasOwnProperty("add")&&g.function(e.add),animeInstance:e=>g.anime(e)||g.tl(e),pixel:e=>e.includes("px"),inObject:(e,t)=>g.object(e)&&t in e,percent:e=>e.includes("%"),scrollable:(e,t)=>t?t==="y"?e.scrollHeight>e.clientHeight:e.scrollWidth>e.clientWidth:e.scrollHeight>e.clientHeight||e.scrollWidth>e.clientWidth};var w=(e,t)=>e&&e.getBoundingClientRect()[t],A=(e,t)=>t==="y"?e.scrollHeight:e.scrollWidth,L=(e,t)=>{g.string(e)&&(e=parseFloat(e));let i=Math.pow(10,t||0);return Math.round(e*i)/i};var R=e=>{if(!g.object(e)&&!g.array(e)||g.animeInstance(e)||e instanceof Element)return e;let t=g.array(e)?[]:{};for(let i in e)e.hasOwnProperty(i)&&(t[i]=R(e[i]));return t},S=(e,t)=>{let i={...e};for(let[s,r]of Object.entries(t)){let n=s;if(g.object(i[n])&&!g.empty(i[n])){if(!g.object(r))continue;i[n]=S(i[n],r)}else i[n]=r}return i},D=e=>{throw new Error(e)},B=(e,t)=>[e,t].sort((i,s)=>i-s),M=e=>{let t={value:0,unit:""},i=/^(-?\d*\.?\d+)(px|%)$/.exec(e);return i&&(t={value:parseFloat(i[1]),unit:i[2]}),t},F=e=>e.split(/\s+/).map(t=>M(t));var y=class{constructor(t){return this._it=t,this.setUtils(),this}setUtils(){this.isVertical=()=>this._it.axis==="y",this.getRoot=t=>this._it._root?this._it._root:t==="resize"?window:t==="scroll"?document:document.documentElement,this.dirProps=()=>this.isVertical()?{ref:"top",length:"height",refOpposite:"bottom",clientLength:document.documentElement.clientHeight}:{ref:"left",length:"width",refOpposite:"right",clientLength:document.documentElement.clientWidth},this.setRootMargin=(t,i)=>{let{length:s,clientLength:r}=this.dirProps(),n=this._it._root?w(this._it._root,s):r,a=(c,u)=>{let{value:p,unit:f,normal:d}=c;return f==="%"?d*u:p};t.pixeled=a(t,n),i.pixeled=a(i,n),this._it._isREPGreater=t.pixeled>=i.pixeled;let o={fromRef:`${-1*(this._it._isREPGreater?i.pixeled:t.pixeled)}px`,fromOppRef:`${(this._it._isREPGreater?t.pixeled:i.pixeled)-n}px`},l=A(this.getRoot(),this.isVertical()?"x":"y");return this.isVertical()?`${o.fromRef} ${l}px ${o.fromOppRef} ${l}px`:`${l}px ${o.fromOppRef} ${l}px ${o.fromRef}`},this.setThreshold=()=>{let t=[0,1];return this._it.triggers.forEach(i=>{let{enter:s,leave:r,maxPosition:n}=this.getTriggerData(i);t.push(s,r,L(1-n,2))}),[...new Set(t)]},this.parseQuery=(t,i="trigger")=>g.string(t)?[...document.querySelectorAll(t)]:g.array(t)?t:g.element(t)?[t]:D(`${i} parameter must be a valid selector, an element or array of elements`),this.parseRoot=t=>{if(!t)return null;if(g.string(t)){let i=document.querySelector(t);return i||D("root parameter must be a valid selector")}return g.element(t)?t:D("root parameter must be an element")},this.validatePosition=t=>(g.function(t)&&(t=t(this._it)),g.string(t)?t:D("enter, leave, rootEnter and rootLeave parameters must be a string.")),this.setPositionData=t=>{t=this.validatePosition(t);let i=t.trim(),s=M(i),r=L(s.value);return{original:i,unit:s.unit,value:r,normal:s.unit==="%"?r/100:0}},this.parsePositions=(t,i,s,r)=>{let n=[t,s,i,r].map(a=>this.setPositionData(this.validatePosition(a).trim()));return{tEP:n[0],rEP:n[1],tLP:n[2],rLP:n[3]}},this.deleteTriggerData=t=>{this._it._triggersData.delete(t)},this.hasTriggerData=(t,i)=>{let s=this._it._triggersData.has(t);return i?s&&i in this.getTriggerData(t):s},this.getTriggerData=(t,i)=>i?this.hasTriggerData(t,i)?this._it._triggersData.get(t)[i]:{}:this.hasTriggerData(t)&&this._it._triggersData.get(t)||{},this.setTriggerData=(t,i,s)=>{if(s){let r=this.getTriggerData(t);"enter"in r&&this._it._triggersData.set(t,{...r,...i});return}this._it._triggersData.set(t,i)},this.getTriggerStates=(t,i)=>{let s=this.getTriggerData(t,"states");return i?s[i]:{...s,hasEnteredFromOneSide:s.hasEntered||s.hasEnteredBack}},this.setTriggerStates=(t,i)=>{let s=this.getTriggerData(t),r=s&&{...s.states,...i};this.setTriggerData(t,{states:r},!0)},this.setTriggerScrollStates=(t,i,s)=>{let r=this.getTriggerStates(t,"onScroll");if(r[i]=s,this.setTriggerStates(t,{onScroll:{...r}}),s){this._it._states.runningScrollCbs===0&&this._it.addScrollListener(this._it._onScrollHandler),this._it._states.runningScrollCbs++;return}0<this._it._states.runningScrollCbs&&this._it._states.runningScrollCbs--,this._it._states.runningScrollCbs===0&&this._it.removeScrollListener(this._it._onScrollHandler)},this.onTriggerEnter=(t,i="Enter")=>{let{hasEnteredOnce:s}=this.getTriggerStates(t),{onEnter:r,onEnterBack:n,toggleClass:a,animation:o}=this.getTriggerData(t),l=i==="Enter",c={callback:l?r:n,enterProp:l?"hasEntered":"hasEnteredBack",leaveProp:l?"hasLeftBack":"hasLeft",eventIndex:l?0:2};if(c.callback(t,this._it),this._it.killed)return this.kill();a&&this._it.toggleClass.toggle(t,a,c.eventIndex),o&&this._it.animation.animate(t,o,c.eventIndex);let u=s?{[c.enterProp]:!0,[c.leaveProp]:!1}:{[c.enterProp]:!0,hasLeft:!1,hasLeftBack:!1};this.setTriggerStates(t,u),s||this.setTriggerStates(t,{hasEnteredOnce:!0})},this.onTriggerLeave=(t,i="Leave")=>{let{once:s}=this.getTriggerData(t),{hasEnteredOnce:r}=this.getTriggerStates(t),{onLeave:n,onLeaveBack:a,toggleClass:o,animation:l}=this.getTriggerData(t),c=i==="Leave",u={callback:c?n:a,leaveProp:c?"hasLeft":"hasLeftBack",eventIndex:c?1:3};if(u.callback(t,this._it),this._it.killed)return this.kill();o&&this._it.toggleClass.toggle(t,o,u.eventIndex),l&&this._it.animation.animate(t,l,u.eventIndex),this.setTriggerStates(t,{[u.leaveProp]:!0,hasEntered:!1,hasEnteredBack:!1}),s&&r&&this._it.remove(t)},this.getPositions=(t,i,{enter:s,leave:r,ref:n,refOpposite:a,length:o})=>{let l=this._it._isREPGreater;return[t[n]+s*t[o],t[n]+r*t[o],l?i[a]:i[n],l?i[n]:i[a]]},this.toggleActions=t=>{let i=t.getBoundingClientRect();this._it.rootBounds=this.getRootRect(this._it.observer.rootMargin);let s=this._it.rootBounds,{hasEnteredFromOneSide:r,hasLeft:n,hasLeftBack:a,hasEnteredOnce:o}=this.getTriggerStates(t),{enter:l,leave:c}=this.getTriggerData(t),{ref:u,refOpposite:p,length:f}=this.dirProps(),[d,T,b,_]=this.getPositions(i,s,{enter:l,leave:c,ref:u,refOpposite:p,length:f}),h=!0;switch(!0){case(a&&b>d):this.onTriggerEnter(t);break;case(r&&_>T):this.onTriggerLeave(t);break;case(n&&o&&_<T):this.onTriggerEnter(t,"EnterBack");break;case(r&&b<d):this.onTriggerLeave(t,"hasLeftBack");break;default:h=!1;break}return h},this.parseRootMargin=t=>{var i=t||"0px",s=F(i);return s[1]=s[1]||s[0],s[2]=s[2]||s[0],s[3]=s[3]||s[1],s},this.expandRectByRootMargin=(t,i)=>{let s=this.parseRootMargin(i).map((n,a)=>n.unit==="px"?n.value:n.value*(a%2?t.width:t.height)/100),r={top:t.top-s[0],right:t.right+s[1],bottom:t.bottom+s[2],left:t.left-s[3],width:0,height:0};return r.width=r.right-r.left,r.height=r.bottom-r.top,r},this.getRootRect=t=>{let i;if(this._it._root&&!g.doc(this._it._root))return i=this._it._root.getBoundingClientRect(),this.expandRectByRootMargin(i,t);let s=g.doc(this._it._root)?this._it._root:document,r=s.documentElement,n=s.body;return i={top:0,left:0,right:r.clientWidth||n.clientWidth,width:r.clientWidth||n.clientWidth,bottom:r.clientHeight||n.clientHeight,height:r.clientHeight||n.clientHeight},this.expandRectByRootMargin(i,t)}}kill(){this._it=void 0}},W=y;var z=[],v=[],N=0,m=class{constructor(t){this._rAFCallback=()=>{this.triggers.forEach(t=>{let i=this._utils.getTriggerStates(t,"onScroll");for(let s in i){let r=s;i[r]&&i[r](t)}})};this._onScrollHandler=()=>this._rAFID=requestAnimationFrame(this._rAFCallback);this._observerCallback=(t,i)=>{let{ref:s,refOpposite:r,length:n}=this._utils.dirProps();for(let a of t){let o=a.target,l=a.boundingClientRect,c=a.isIntersecting;this.rootBounds=a.rootBounds||this._utils.getRootRect(i.rootMargin);let u=this.rootBounds,p=u[n],{enter:f,leave:d}=this._utils.getTriggerData(o),{hasEnteredFromOneSide:T,onScroll:{backup:b}}=this._utils.getTriggerStates(o),[_,h,E,k]=this._utils.getPositions(l,u,{enter:f,leave:d,ref:s,refOpposite:r,length:n}),O=l[n]>=p,x=!!b;switch(!0){case this._states.oCbFirstInvoke:switch(!0){case(!c&&k>h):this._utils.onTriggerEnter(o),this._utils.onTriggerLeave(o);break;case c:switch(!0){case(E>_&&k<h):this._utils.onTriggerEnter(o);break;case k>h:this._utils.onTriggerEnter(o),this._utils.onTriggerLeave(o);break}O&&this._utils.setTriggerScrollStates(o,"backup",this._utils.toggleActions);break}break;case!c:switch(x&&this._utils.setTriggerScrollStates(o,"backup"),!0){case(T&&k>h):this._utils.onTriggerLeave(o);break;case(T&&E<_):this._utils.onTriggerLeave(o,"onLeaveBack");break}break;case(c&&!x):this._utils.toggleActions(o),O&&this._utils.setTriggerScrollStates(o,"backup",this._utils.toggleActions);break}}this._states.oCbFirstInvoke=!1};this._userOptions=t||{},this.triggers=[],this._triggersData=new WeakMap,this._utils=new W(this),this.id=N,N++,v.push(this),this.animation=void 0,this.toggleClass=void 0,this.guides=void 0,this._states={oCbFirstInvoke:!0,runningScrollCbs:0},this._setInstance()}_setPlugin(t){let s=m.getRegisteredPlugins().find(r=>t===r.pluginName);s&&(this[t]=new s(this))}_addResizeListener(){this._removeResizeListener(),this._onResizeHandler=()=>this.update(),this._utils.getRoot("resize").addEventListener("resize",this._onResizeHandler,!1)}_removeResizeListener(){this._utils.getRoot("resize").removeEventListener("resize",this._onResizeHandler,!1)}addScrollListener(t){this._utils.getRoot("scroll").addEventListener("scroll",t,!1)}removeScrollListener(t){this._utils.getRoot("scroll").removeEventListener("scroll",t,!1)}_createInstance(){this._rootMargin=this._utils.setRootMargin(this._positionsData.rEP,this._positionsData.rLP),this._threshold=this._utils.setThreshold(),this.observer=new IntersectionObserver(this._observerCallback,{root:this._root,rootMargin:this._rootMargin,threshold:this._threshold}),this._root=this.observer.root,this.rootBounds=this._utils.getRootRect(this.observer.rootMargin)}_setInstance(){this._defaultOptions=I,this._options=S(this._defaultOptions,this._userOptions);let{axis:t,name:i,root:s,defaults:{enter:r,leave:n},onScroll:a,rootEnter:o,rootLeave:l,guides:c}=this._options;return this.axis=t,this.name=i,this._root=this._utils.parseRoot(s),this._positionsData=this._utils.parsePositions(r,n,o,l),this.customScrollHandler=a,this._createInstance(),this._addResizeListener(),this.customScrollHandler&&this.addScrollListener(this.customScrollHandler),c&&(this._setPlugin("guides"),this.guides.init(c)),this}add(t,i){let s=this._utils.parseQuery(t),{defaults:r}=this._options,n=i||{},a=(h,E="tEP")=>h?this._utils.setPositionData(h).normal:this._positionsData[E].normal,o=h=>(!this[h]&&this._setPlugin(h),this[h]),l=S(r,n),{enter:c,leave:u,toggleClass:p,animation:f}=l,d={...l,enter:a(c),leave:a(u,"tLP"),toggleClass:p?o("toggleClass").parse(p):void 0,animation:f?o("animation").parse(f):void 0,states:H},[T,b]=B(d.enter,d.leave);d.minPosition=T,d.maxPosition=b,this.triggers=[...new Set([...this.triggers,...s])];let _=!1;return[d.enter,d.leave].forEach(h=>!this._threshold.some(E=>h===E)&&(_=!0)),_?(s.forEach(h=>this._utils.setTriggerData(h,R(d))),this.update()):s.forEach(h=>{this._utils.setTriggerData(h,R(d)),this.observer.observe(h)}),this.guides&&this.guides.update(),this}remove(t){let i=this._utils.parseQuery(t);i.forEach(r=>{this._utils.deleteTriggerData(r),this.observer.unobserve(r)});let s=this.triggers.filter(r=>!i.some(a=>r===a));return this.triggers=s,this.guides&&this.guides.update(),this}_disconnect(){this.observer&&this.observer.disconnect(),this.observer=void 0}update(){this._disconnect(),this._createInstance(),this.triggers.forEach(t=>this.observer&&this.observer.observe(t)),this.guides&&this.guides.update()}kill(){this.killed=!0,this._disconnect(),this.removeScrollListener(this._onScrollHandler),this.removeScrollListener(this.customScrollHandler),this._removeResizeListener(),this._rAFID&&cancelAnimationFrame(this._rAFID),this.guides&&this.guides.kill(),this.toggleClass&&this.toggleClass.kill(),this.animation&&this.animation.kill(),this.triggers=[],this.animation=this.toggleClass=this.guides=this._utils=void 0;let t=v.indexOf(this);~t&&v.splice(t,1)}};m.getInstances=()=>v;m.getInstanceById=e=>v.find(t=>t.id===e);m.update=()=>v.forEach(e=>e.update());m.kill=()=>v.forEach(e=>e.kill());m.registerPlugins=(e=[])=>z.push(...e);m.getRegisteredPlugins=()=>z;var V=m;
