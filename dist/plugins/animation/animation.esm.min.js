/*
* IntersectionTrigger v1.1.0 
* IntersectionTrigger utilizes the most modern web technology to trigger anything by intersection. Including scroll-based animations.
* https://sunshine-themes.com/?appID=ss_app_1
*
* Copyright 2023, Sunshine. All rights reserved.
* @license: Released under the personal 'no charge' license can be viewed at http://sunshine-themes.com/?appID=ss_app_1&tab=license, Licensees of commercial or business license are granted additional rights. See http://sunshine-themes.com/?appID=ss_app_1&tab=license for details..
* @author: Sherif Magdy, sherifmagdy@sunshine-themes.com
*
* Released on: February 17, 2023
*/

var a={function:e=>typeof e=="function",string:e=>typeof e=="string",boolean:e=>typeof e=="boolean",object:e=>!!e&&typeof e=="object"&&e!==null&&!(e instanceof Array),num:e=>typeof e=="number",array:e=>e instanceof Array,element:e=>e instanceof HTMLElement,empty:e=>Object.keys(e).length===0,doc:e=>a.element(e)&&e.nodeType===9,anime:e=>a.object(e)&&e.hasOwnProperty("animatables")&&!e.hasOwnProperty("add"),tl:e=>a.object(e)&&e.hasOwnProperty("add")&&a.function(e.add),animeInstance:e=>a.anime(e)||a.tl(e),pixel:e=>e.includes("px"),inObject:(e,t)=>a.object(e)&&t in e,percent:e=>e.includes("%"),scrollable:(e,t)=>t?t==="y"?e.scrollHeight>e.clientHeight:e.scrollWidth>e.clientWidth:e.scrollHeight>e.clientHeight||e.scrollWidth>e.clientWidth},w=(e,t,g)=>Math.min(Math.max(e,t),g),H=e=>e.split(/\s+/);var y=(e,t)=>{let g={...e};for(let[p,i]of Object.entries(t)){let d=p;if(a.object(g[d])&&!a.empty(g[d])){if(!a.object(i))continue;g[d]=y(g[d],i)}else g[d]=i}return g},T=e=>{throw new Error(e)};var j=()=>{},R={to:0,after:1,speed:100,maxDistance:500,onStart:j,onComplete:j};var _={instance:{},toggleActions:"play complete reverse complete",link:!1,snap:!1};var v=class{constructor(t){return this._registerIntersectionTrigger(t),this.setUtils(),this}_registerIntersectionTrigger(t){this._it=t,this._utils=this._it._utils}setUtils(){let{ref:t,refOpposite:g,length:p}=this._utils.dirProps(),i=this._utils.isVertical(),d=this._utils.getRoot(),m=new WeakMap;this.seekSmoothly=(s,n,c,o)=>{if(this.killed)return;let u=s.currentTime,r=o?Math.min(u+c,n):Math.max(u-c,n);if(s.seek(r),o?r>=n:r<=n)return;let h=requestAnimationFrame(()=>this.seekSmoothly(s,n,c,o));m.set(s,h)},this.seek=(s,n,c)=>{if(a.num(c)){let o=s.currentTime,u=n>o,r=m.has(s)&&m.get(s)||0;cancelAnimationFrame(r),this.seekSmoothly(s,n,c,u);return}s.seek(n)},this.startSnaping=({snapDistance:s,currentDis:n,snap:c,step:o,toRef:u=!1})=>{if(this.killed)return;let r=u?-1:1;if(i?d.scrollBy({top:o*r,behavior:"instant"}):d.scrollBy({left:o*r,behavior:"instant"}),n+=o,n>=s){n=0,c.onComplete(this._it);return}requestAnimationFrame(()=>this.startSnaping({snapDistance:s,currentDis:n,snap:c,step:o,toRef:u}))},this.parseSnap=({instance:s,snap:n},c)=>{let o=l=>{let S=[],b=0;for(;b<=1;)S.push(w(b,0,1)),b=b+l;return S.map(A=>Math.round(A*s.duration))},u=()=>a.inObject(s,"marks")?s.marks.map(l=>l.time):T('"marks" feature is not available in the provided anime instance'),r=l=>y(R,l),k=l=>a.num(l)?o(l):u(),h={},f={};if(c){let{originalToParam:l}=n;l&&(h={...n,to:k(l)})}else{a.boolean(n)&&(f=r({to:"marks"})),(a.array(n)||a.num(n))&&(f=r({to:n})),a.object(n)&&(f=r(n)),h=f;let{to:l}=f;a.string(l)&&!!l&&(h={...f,originalToParam:"marks",to:u()}),a.num(l)&&!!l&&(h={...f,originalToParam:l,to:o(l)})}return h},this.getTIL=(s,n,c)=>{let o=s.getBoundingClientRect();return o[p]-(n*o[p]+(1-c)*o[p])},this.getSnapStep=s=>a.object(s)?Math.round(Math.max(s.speed*17/1e3,1)):0,this.animateHandler=(s,{enter:n,leave:c,tIL:o,instance:u,snap:r,step:k,link:h})=>{if(this.killed)return;let f=s.getBoundingClientRect(),l=this._utils.getTriggerStates(s,"ids");this._it.rootBounds=this._utils.getRootRect(this._it.observer.rootMargin);let S=this._it.rootBounds,b=o+(this._it._isREPGreater?S[p]:-S[p]),A=u.duration,P=0,D=this._utils.getPositions(f,S,{enter:n,leave:c,ref:t,refOpposite:g,length:p}),C=D[2]-D[0];if(C>0&&(P=A*C/b,this.seek(u,P,h)),!a.boolean(r)){let B=0;clearTimeout(l.snapTimeOutId);let F=setTimeout(()=>{let E=r.to.map(O=>P-O),M=E.map(O=>Math.abs(O)),x=Math.min(...M),W=E[M.indexOf(x)],I=b*x/A,L={snapDistance:I,currentDis:B,snap:r,step:k};if(!(I>=r.maxDistance||I<k)){if(r.onStart(this._it),W<0){this.startSnaping(L);return}this.startSnaping({...L,toRef:!0})}},r.after*1e3);this._utils.setTriggerStates(s,{ids:{...l,snapTimeOutId:F}})}}}animate(t,g,p){let{instance:i,toggleActions:d,link:m,snap:s}=g;if(m){let{animate:o}=this._utils.getTriggerStates(t,"onScroll"),u=this._utils.getTriggerStates(t,"ids"),{enter:r,leave:k,minPosition:h,maxPosition:f}=this._utils.getTriggerData(t),l=this.getTIL(t,h,f),S=this.getSnapStep(s),b={enter:r,leave:k,tIL:l,instance:i,snap:s,link:a.boolean(m)?m:Math.abs(m),step:S};switch(p){case 0:case 2:if(this._it._states.oCbFirstInvoke&&this.animateHandler(t,b),o)break;this._utils.setTriggerScrollStates(t,"animate",()=>this.animateHandler(t,b));break;case 1:case 3:clearTimeout(u.snapTimeOutId),this._utils.setTriggerScrollStates(t,"animate"),this.seek(i,p===1?i.duration:0,m);break}return}let n=d[p],c=i.currentTime/i.duration;if(n!=="none")switch(n){case"play":i.reversed&&(i.reverse(),i.completed=!1),c<1&&i[n]();break;case"resume":c<1&&c>0&&i.play();break;case"restart":case"reset":i.reversed&&i.reverse(),i[n]();break;case"pause":i[n]();break;case"complete":i.pause(),i.seek(i.reversed?0:i.duration);break;case"reverse":!i.reversed&&i[n](),i.paused&&i.play();break;case"kill":a.inObject(i,"kill")&&i.kill(),this._utils.setTriggerData(t,{animation:void 0},!0);break}}parse(t,g){let p={},i={};if(g){let{instance:d,snap:m}=t;!a.boolean(m)&&(i={...t,snap:this.parseSnap({instance:d,snap:m},!0)})}else{if(!a.object(t))return T('"animation" parameter is NOT valid.');if(a.animeInstance(t))p=y(_,{instance:t});else if(t.instance&&a.animeInstance(t.instance))p=y(_,t);else return T('"instance" parameter must be anime instance.');let{toggleActions:d,snap:m,instance:s,link:n}=p;i={instance:s,toggleActions:H(d),snap:!!m&&this.parseSnap({instance:s,snap:m}),link:n}}return i.instance.reset(),i}update(){this._it.triggers.forEach(t=>{let{enter:g,leave:p,minPosition:i,maxPosition:d,animation:m}=this._utils.getTriggerData(t);m=m&&this.parse(m,!0),this._utils.setTriggerData(t,{animation:m},!0);let{animate:s}=this._utils.getTriggerStates(t,"onScroll");if(s&&!!m){let{instance:n,snap:c,link:o}=m,u=this.getTIL(t,i,d),r=this.getSnapStep(c);this._utils.setTriggerScrollStates(t,"animate"),this._utils.setTriggerScrollStates(t,"animate",()=>this.animateHandler(t,{enter:g,leave:p,instance:n,snap:c,link:o,tIL:u,step:r}))}})}kill(){this.killed=!0,this._it=this._utils=void 0}};v.pluginName="animation";var G=v;export{G as default};
//# sourceMappingURL=animation.esm.min.js.map
