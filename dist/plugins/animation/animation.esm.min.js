/*
* IntersectionTrigger v1.1.2 
* IntersectionTrigger utilizes the most modern web technology to trigger anything by intersection. Including scroll-based animations.
* https://sunshine-themes.com/?appID=ss_app_1
*
* Copyright 2023, Sunshine. All rights reserved.
* @license: Released under the personal 'no charge' license can be viewed at http://sunshine-themes.com/?appID=ss_app_1&tab=license, Licensees of commercial or business license are granted additional rights. See http://sunshine-themes.com/?appID=ss_app_1&tab=license for details..
* @author: Sherif Magdy, sherifmagdy@sunshine-themes.com
*
* Released on: February 25, 2023
*/

var a={function:e=>typeof e=="function",string:e=>typeof e=="string",boolean:e=>typeof e=="boolean",object:e=>!!e&&typeof e=="object"&&e!==null&&!(e instanceof Array),num:e=>typeof e=="number",array:e=>e instanceof Array,element:e=>e instanceof HTMLElement,empty:e=>Object.keys(e).length===0,doc:e=>a.element(e)&&e.nodeType===9,anime:e=>a.object(e)&&e.hasOwnProperty("animatables")&&!e.hasOwnProperty("add"),tl:e=>a.object(e)&&e.hasOwnProperty("add")&&a.function(e.add),animeInstance:e=>a.anime(e)||a.tl(e),pixel:e=>e.includes("px"),inObject:(e,t)=>a.object(e)&&t in e,percent:e=>e.includes("%"),scrollable:(e,t)=>t?t==="y"?e.scrollHeight>e.clientHeight:e.scrollWidth>e.clientWidth:e.scrollHeight>e.clientHeight||e.scrollWidth>e.clientWidth},L=(e,t,g)=>Math.min(Math.max(e,t),g),H=e=>e.split(/\s+/);var k=(e,t)=>{let g={...e};for(let[p,i]of Object.entries(t)){let d=p;if(a.object(g[d])&&!a.empty(g[d])){if(!a.object(i))continue;g[d]=k(g[d],i)}else g[d]=i}return g},T=e=>{throw new Error(e)};var R=()=>{},B={to:0,after:1,speed:100,maxDistance:500,onStart:R,onComplete:R};var v={instance:{},toggleActions:"play complete reverse complete",link:!1,snap:!1};var _=class{constructor(t){return this._registerIntersectionTrigger(t),this.setUtils(),this}_registerIntersectionTrigger(t){this._it=t,this._utils=this._it._utils}setUtils(){let{ref:t,refOpposite:g,length:p}=this._utils.dirProps(),i=this._utils.isVertical(),d=this._utils.getRoot(),m=new WeakMap;this.seekSmoothly=(s,n,c,o)=>{if(this.killed)return;let u=s.currentTime,r=o?Math.min(u+c,n):Math.max(u-c,n);if(s.seek(r),o?r>=n:r<=n)return;let f=requestAnimationFrame(()=>this.seekSmoothly(s,n,c,o));m.set(s,f)},this.seek=(s,n,c)=>{if(a.num(c)){let o=s.currentTime,u=n>o,r=m.has(s)&&m.get(s)||0;cancelAnimationFrame(r),this.seekSmoothly(s,n,c,u);return}s.seek(n)},this.startSnaping=({snapDistance:s,currentDis:n,snap:c,step:o,toRef:u=!1})=>{if(this.killed)return;let r=u?-1:1;if(i?d.scrollBy({top:o*r,behavior:"instant"}):d.scrollBy({left:o*r,behavior:"instant"}),n+=o,n>=s){n=0,c.onComplete(this._it);return}requestAnimationFrame(()=>this.startSnaping({snapDistance:s,currentDis:n,snap:c,step:o,toRef:u}))},this.parseSnap=({instance:s,snap:n},c)=>{let o=l=>{let S=[],b=0;for(;b<=1;)S.push(L(b,0,1)),b=b+l;return S.map(A=>Math.round(A*s.duration))},u=()=>a.inObject(s,"marks")?s.marks.map(l=>l.time):T('"marks" feature is not available in the provided anime instance'),r=l=>k(B,l),y=l=>a.num(l)?o(l):u(),f={},h={};if(c){let{originalToParam:l}=n;l&&(f={...n,to:y(l)})}else{a.boolean(n)&&(h=r({to:"marks"})),(a.array(n)||a.num(n))&&(h=r({to:n})),a.object(n)&&(h=r(n)),f=h;let{to:l}=h;a.string(l)&&!!l&&(f={...h,originalToParam:"marks",to:u()}),a.num(l)&&!!l&&(f={...h,originalToParam:l,to:o(l)})}return f},this.getTIL=(s,n,c)=>{let o=s.getBoundingClientRect();return o[p]-(n*o[p]+(1-c)*o[p])},this.getSnapStep=s=>a.object(s)?Math.round(Math.max(s.speed*17/1e3,1)):0,this.animateHandler=(s,{enter:n,leave:c,tIL:o,instance:u,snap:r,step:y,link:f})=>{if(this.killed)return;let h=s.getBoundingClientRect(),l=this._utils.getTriggerData(s,"states").ids,S=this._it.rootBounds=this._utils.getRootRect(this._it.observer.rootMargin),b=o+(this._it._isREPGreater?S[p]:-S[p]),A=u.duration,D=this._utils.getPositions(h,S,{enter:n,leave:c,ref:t,refOpposite:g,length:p}),C=D[2]-D[0],P=0;if(C>0&&(P=A*C/b,this.seek(u,P,f)),!a.boolean(r)){let j=0;clearTimeout(l.snapTimeOutId);let F=setTimeout(()=>{let E=r.to.map(O=>P-O),M=E.map(O=>Math.abs(O)),w=Math.min(...M),W=E[M.indexOf(w)],I=b*w/A,x={snapDistance:I,currentDis:j,snap:r,step:y};if(!(I>=r.maxDistance||I<y)){if(r.onStart(this._it),W<0){this.startSnaping(x);return}this.startSnaping({...x,toRef:!0})}},r.after*1e3);this._utils.setTriggerStates(s,{ids:{...l,snapTimeOutId:F}})}}}animate(t,g,p){let{instance:i,toggleActions:d,link:m,snap:s}=g;if(m){let{enter:o,leave:u,minPosition:r,maxPosition:y,states:{onScroll:{animate:f},ids:h}}=this._utils.getTriggerData(t),l=this.getTIL(t,r,y),S=this.getSnapStep(s),b={enter:o,leave:u,tIL:l,instance:i,snap:s,link:a.boolean(m)?m:Math.abs(m),step:S};switch(p){case 0:case 2:if(this._it._states.oCbFirstInvoke&&this.animateHandler(t,b),f)break;this._utils.setTriggerScrollStates(t,"animate",()=>this.animateHandler(t,b));break;case 1:case 3:clearTimeout(h.snapTimeOutId),this._utils.setTriggerScrollStates(t,"animate"),this.seek(i,p===1?i.duration:0,m);break}return}let n=d[p],c=i.currentTime/i.duration;if(n!=="none")switch(n){case"play":i.reversed&&(i.reverse(),i.completed=!1),c<1&&i[n]();break;case"resume":c<1&&c>0&&i.play();break;case"restart":case"reset":i.reversed&&i.reverse(),i[n]();break;case"pause":i[n]();break;case"complete":i.pause(),i.seek(i.reversed?0:i.duration);break;case"reverse":!i.reversed&&i[n](),i.paused&&i.play();break;case"kill":a.inObject(i,"kill")&&i.kill(),this._utils.setTriggerData(t,{animation:void 0},!0);break}}parse(t,g){let p={},i={};if(g){let{instance:d,snap:m}=t;!a.boolean(m)&&(i={...t,snap:this.parseSnap({instance:d,snap:m},!0)})}else{if(!a.object(t))return T('"animation" parameter is NOT valid.');if(a.animeInstance(t))p=k(v,{instance:t});else if(t.instance&&a.animeInstance(t.instance))p=k(v,t);else return T('"instance" parameter must be anime instance.');let{toggleActions:d,snap:m,instance:s,link:n}=p;i={instance:s,toggleActions:H(d),snap:!!m&&this.parseSnap({instance:s,snap:m}),link:n}}return i.instance.reset(),i}update(){this._it.triggers.forEach(t=>{let{enter:g,leave:p,minPosition:i,maxPosition:d,animation:m}=this._utils.getTriggerData(t);m=m&&this.parse(m,!0),this._utils.setTriggerData(t,{animation:m},!0);let{animate:s}=this._utils.getTriggerData(t,"states").onScroll;if(s&&!!m){let{instance:n,snap:c,link:o}=m,u=this.getTIL(t,i,d),r=this.getSnapStep(c);this._utils.setTriggerScrollStates(t,"animate"),this._utils.setTriggerScrollStates(t,"animate",()=>this.animateHandler(t,{enter:g,leave:p,instance:n,snap:c,link:o,tIL:u,step:r}))}})}kill(){this.killed=!0,this._it=this._utils=void 0}};_.pluginName="animation";var G=_;export{G as default};
//# sourceMappingURL=animation.esm.min.js.map
