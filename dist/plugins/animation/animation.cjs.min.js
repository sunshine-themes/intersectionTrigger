/*
* IntersectionTrigger v1.1.0 
* IntersectionTrigger utilizes the most modern web technology to trigger anything by intersection. Including scroll-based animations.
* https://sunshine-themes.com/?appID=ss_app_1
*
* Copyright 2023, Sunshine. All rights reserved.
* @license: Released under the personal 'no charge' license can be viewed at http://sunshine-themes.com/?appID=ss_app_1&tab=license, Licensees of commercial or business license are granted additional rights. See http://sunshine-themes.com/?appID=ss_app_1&tab=license for details..
* @author: Sherif Magdy, sherifmagdy@sunshine-themes.com
*
* Released on: February 17, 2023
*/

var w=Object.defineProperty;var N=e=>w(e,"__esModule",{value:!0});var U=(e,t)=>{for(var p in t)w(e,p,{get:t[p],enumerable:!0})};N(exports);U(exports,{default:()=>V});var a={function:e=>typeof e=="function",string:e=>typeof e=="string",boolean:e=>typeof e=="boolean",object:e=>!!e&&typeof e=="object"&&e!==null&&!(e instanceof Array),num:e=>typeof e=="number",array:e=>e instanceof Array,element:e=>e instanceof HTMLElement,empty:e=>Object.keys(e).length===0,doc:e=>a.element(e)&&e.nodeType===9,anime:e=>a.object(e)&&e.hasOwnProperty("animatables")&&!e.hasOwnProperty("add"),tl:e=>a.object(e)&&e.hasOwnProperty("add")&&a.function(e.add),animeInstance:e=>a.anime(e)||a.tl(e),pixel:e=>e.includes("px"),inObject:(e,t)=>a.object(e)&&t in e,percent:e=>e.includes("%"),scrollable:(e,t)=>t?t==="y"?e.scrollHeight>e.clientHeight:e.scrollWidth>e.clientWidth:e.scrollHeight>e.clientHeight||e.scrollWidth>e.clientWidth},H=(e,t,p)=>Math.min(Math.max(e,t),p),j=e=>e.split(/\s+/);var y=(e,t)=>{let p={...e};for(let[u,i]of Object.entries(t)){let d=u;if(a.object(p[d])&&!a.empty(p[d])){if(!a.object(i))continue;p[d]=y(p[d],i)}else p[d]=i}return p},T=e=>{throw new Error(e)};var R=()=>{},B={to:0,after:1,speed:100,maxDistance:500,onStart:R,onComplete:R};var _={instance:{},toggleActions:"play complete reverse complete",link:!1,snap:!1};var v=class{constructor(t){return this._registerIntersectionTrigger(t),this.setUtils(),this}_registerIntersectionTrigger(t){this._it=t,this._utils=this._it._utils}setUtils(){let{ref:t,refOpposite:p,length:u}=this._utils.dirProps(),i=this._utils.isVertical(),d=this._utils.getRoot(),m=new WeakMap;this.seekSmoothly=(s,n,c,o)=>{if(this.killed)return;let g=s.currentTime,r=o?Math.min(g+c,n):Math.max(g-c,n);if(s.seek(r),o?r>=n:r<=n)return;let h=requestAnimationFrame(()=>this.seekSmoothly(s,n,c,o));m.set(s,h)},this.seek=(s,n,c)=>{if(a.num(c)){let o=s.currentTime,g=n>o,r=m.has(s)&&m.get(s)||0;cancelAnimationFrame(r),this.seekSmoothly(s,n,c,g);return}s.seek(n)},this.startSnaping=({snapDistance:s,currentDis:n,snap:c,step:o,toRef:g=!1})=>{if(this.killed)return;let r=g?-1:1;if(i?d.scrollBy({top:o*r,behavior:"instant"}):d.scrollBy({left:o*r,behavior:"instant"}),n+=o,n>=s){n=0,c.onComplete(this._it);return}requestAnimationFrame(()=>this.startSnaping({snapDistance:s,currentDis:n,snap:c,step:o,toRef:g}))},this.parseSnap=({instance:s,snap:n},c)=>{let o=l=>{let S=[],b=0;for(;b<=1;)S.push(H(b,0,1)),b=b+l;return S.map(A=>Math.round(A*s.duration))},g=()=>a.inObject(s,"marks")?s.marks.map(l=>l.time):T('"marks" feature is not available in the provided anime instance'),r=l=>y(B,l),k=l=>a.num(l)?o(l):g(),h={},f={};if(c){let{originalToParam:l}=n;l&&(h={...n,to:k(l)})}else{a.boolean(n)&&(f=r({to:"marks"})),(a.array(n)||a.num(n))&&(f=r({to:n})),a.object(n)&&(f=r(n)),h=f;let{to:l}=f;a.string(l)&&!!l&&(h={...f,originalToParam:"marks",to:g()}),a.num(l)&&!!l&&(h={...f,originalToParam:l,to:o(l)})}return h},this.getTIL=(s,n,c)=>{let o=s.getBoundingClientRect();return o[u]-(n*o[u]+(1-c)*o[u])},this.getSnapStep=s=>a.object(s)?Math.round(Math.max(s.speed*17/1e3,1)):0,this.animateHandler=(s,{enter:n,leave:c,tIL:o,instance:g,snap:r,step:k,link:h})=>{if(this.killed)return;let f=s.getBoundingClientRect(),l=this._utils.getTriggerStates(s,"ids");this._it.rootBounds=this._utils.getRootRect(this._it.observer.rootMargin);let S=this._it.rootBounds,b=o+(this._it._isREPGreater?S[u]:-S[u]),A=g.duration,P=0,D=this._utils.getPositions(f,S,{enter:n,leave:c,ref:t,refOpposite:p,length:u}),C=D[2]-D[0];if(C>0&&(P=A*C/b,this.seek(g,P,h)),!a.boolean(r)){let F=0;clearTimeout(l.snapTimeOutId);let W=setTimeout(()=>{let E=r.to.map(O=>P-O),M=E.map(O=>Math.abs(O)),x=Math.min(...M),q=E[M.indexOf(x)],I=b*x/A,L={snapDistance:I,currentDis:F,snap:r,step:k};if(!(I>=r.maxDistance||I<k)){if(r.onStart(this._it),q<0){this.startSnaping(L);return}this.startSnaping({...L,toRef:!0})}},r.after*1e3);this._utils.setTriggerStates(s,{ids:{...l,snapTimeOutId:W}})}}}animate(t,p,u){let{instance:i,toggleActions:d,link:m,snap:s}=p;if(m){let{animate:o}=this._utils.getTriggerStates(t,"onScroll"),g=this._utils.getTriggerStates(t,"ids"),{enter:r,leave:k,minPosition:h,maxPosition:f}=this._utils.getTriggerData(t),l=this.getTIL(t,h,f),S=this.getSnapStep(s),b={enter:r,leave:k,tIL:l,instance:i,snap:s,link:a.boolean(m)?m:Math.abs(m),step:S};switch(u){case 0:case 2:if(this._it._states.oCbFirstInvoke&&this.animateHandler(t,b),o)break;this._utils.setTriggerScrollStates(t,"animate",()=>this.animateHandler(t,b));break;case 1:case 3:clearTimeout(g.snapTimeOutId),this._utils.setTriggerScrollStates(t,"animate"),this.seek(i,u===1?i.duration:0,m);break}return}let n=d[u],c=i.currentTime/i.duration;if(n!=="none")switch(n){case"play":i.reversed&&(i.reverse(),i.completed=!1),c<1&&i[n]();break;case"resume":c<1&&c>0&&i.play();break;case"restart":case"reset":i.reversed&&i.reverse(),i[n]();break;case"pause":i[n]();break;case"complete":i.pause(),i.seek(i.reversed?0:i.duration);break;case"reverse":!i.reversed&&i[n](),i.paused&&i.play();break;case"kill":a.inObject(i,"kill")&&i.kill(),this._utils.setTriggerData(t,{animation:void 0},!0);break}}parse(t,p){let u={},i={};if(p){let{instance:d,snap:m}=t;!a.boolean(m)&&(i={...t,snap:this.parseSnap({instance:d,snap:m},!0)})}else{if(!a.object(t))return T('"animation" parameter is NOT valid.');if(a.animeInstance(t))u=y(_,{instance:t});else if(t.instance&&a.animeInstance(t.instance))u=y(_,t);else return T('"instance" parameter must be anime instance.');let{toggleActions:d,snap:m,instance:s,link:n}=u;i={instance:s,toggleActions:j(d),snap:!!m&&this.parseSnap({instance:s,snap:m}),link:n}}return i.instance.reset(),i}update(){this._it.triggers.forEach(t=>{let{enter:p,leave:u,minPosition:i,maxPosition:d,animation:m}=this._utils.getTriggerData(t);m=m&&this.parse(m,!0),this._utils.setTriggerData(t,{animation:m},!0);let{animate:s}=this._utils.getTriggerStates(t,"onScroll");if(s&&!!m){let{instance:n,snap:c,link:o}=m,g=this.getTIL(t,i,d),r=this.getSnapStep(c);this._utils.setTriggerScrollStates(t,"animate"),this._utils.setTriggerScrollStates(t,"animate",()=>this.animateHandler(t,{enter:p,leave:u,instance:n,snap:c,link:o,tIL:g,step:r}))}})}kill(){this.killed=!0,this._it=this._utils=void 0}};v.pluginName="animation";var V=v;
