/*
* IntersectionTrigger v1.0.4 
* IntersectionTrigger utilizes the most modern web technology to trigger anything by intersection. Including scroll-based animations.
* https://sunshine-themes.com/?appID=ss_app_1
*
* Copyright 2023, Sunshine. All rights reserved.
* @license: Released under the personal 'no charge' license can be viewed at http://sunshine-themes.com/?appID=ss_app_1&tab=license, Licensees of commercial or business license are granted additional rights. See http://sunshine-themes.com/?appID=ss_app_1&tab=license for details..
* @author: Sherif Magdy, sherifmagdy@sunshine-themes.com
*
* Released on: February 8, 2023
*/

var O=()=>{},H={to:0,after:1,speed:100,maxDistance:500,onStart:O,onComplete:O};var I={instance:{},toggleActions:"play complete reverse complete",link:!1,snap:!1};var o={function:e=>typeof e=="function",string:e=>typeof e=="string",boolean:e=>typeof e=="boolean",object:e=>!!e&&typeof e=="object"&&e!==null&&!(e instanceof Array),num:e=>typeof e=="number",array:e=>e instanceof Array,element:e=>e instanceof HTMLElement,empty:e=>Object.keys(e).length===0,doc:e=>o.element(e)&&e.nodeType===9,anime:e=>o.object(e)&&e.hasOwnProperty("animatables")&&!e.hasOwnProperty("add"),tl:e=>o.object(e)&&e.hasOwnProperty("add")&&o.function(e.add),animeInstance:e=>o.anime(e)||o.tl(e),pixel:e=>e.includes("px"),inObject:(e,t)=>o.object(e)&&t in e,percent:e=>e.includes("%"),scrollable:(e,t)=>t?t==="y"?e.scrollHeight>e.clientHeight:e.scrollWidth>e.clientWidth:e.scrollHeight>e.clientHeight||e.scrollWidth>e.clientWidth},w=(e,t,p)=>Math.min(Math.max(e,t),p),B=e=>e.split(/\s+/);var S=(e,t)=>{let p={...e};for(let[c,i]of Object.entries(t))if(o.object(p[c])&&!o.empty(p[c])){if(!o.object(i))continue;p[c]=S(p[c],i)}else p[c]=i;return p},k=e=>{throw new Error(e)};var v=class{constructor(t){return this._registerIntersectionTrigger(t),this.setUtils(),this}_registerIntersectionTrigger(t){this._it=t,this._utils=this._it._utils}setUtils(){let{ref:t,refOpposite:p,length:c}=this._utils.dirProps(),i=this._utils.isVertical(),h=this._utils.getRoot(),m=new WeakMap;this.seekSmoothly=(a,n,u,s)=>{if(this.killed)return;let g=a.currentTime,r=s?Math.min(g+u,n):Math.max(g-u,n);if(a.seek(r),s?r>=n:r<=n)return;let f=requestAnimationFrame(()=>this.seekSmoothly(a,n,u,s));m.set(a,f)},this.seek=(a,n,u)=>{if(o.num(u)){let s=a.currentTime,g=n>s,r=m.has(a)&&m.get(a)||0;cancelAnimationFrame(r),this.seekSmoothly(a,n,u,g);return}a.seek(n)},this.startSnaping=({snapDistance:a,currentDis:n,snap:u,step:s,toRef:g=!1})=>{if(this.killed)return;let r=g?-1:1;if(i?h.scrollBy({top:s*r,behavior:"instant"}):h.scrollBy({left:s*r,behavior:"instant"}),n+=s,n>=a){n=0,u.onComplete(this._it);return}requestAnimationFrame(()=>this.startSnaping({snapDistance:a,currentDis:n,snap:u,step:s,toRef:g}))},this.parseSnap=({instance:a,snap:n},u)=>{let s=l=>{let A=[],b=0;for(;b<=1;)A.push(w(b,0,1)),b=b+l;return A.map(C=>Math.round(C*a.duration))},g=()=>o.inObject(a,"marks")?a.marks.map(l=>l.time):k('"marks" feature is not available in the provided anime instance'),r=l=>S(H,l),T=l=>o.num(l)?s(l):g(),f={},d={};if(u){let{originalToParam:l}=n;l&&(f={...n,to:T(l)})}else{o.boolean(n)&&(d=r({to:"marks"})),(o.array(n)||o.num(n))&&(d=r({to:n})),o.object(n)&&(d=r(n)),f=d;let{to:l}=d;o.string(l)&&!!l&&(f={...d,originalToParam:"marks",to:g()}),o.num(l)&&!!l&&(f={...d,originalToParam:l,to:s(l)}),console.log(f.to)}return f},this.getTIL=(a,n,u)=>{let s=a.getBoundingClientRect();return s[c]-(n*s[c]+(1-u)*s[c])},this.getSnapStep=a=>o.object(a)?Math.round(Math.max(a.speed*17/1e3,1)):0,this.animateHandler=(a,{enter:n,leave:u,tIL:s,instance:g,snap:r,step:T,link:f})=>{if(this.killed)return;let d=a.getBoundingClientRect(),l=this._utils.getTriggerStates(a,"ids");this._it.rootBounds=this._utils.getRootRect(this._it.observer.rootMargin);let A=this._it.rootBounds,b=s+(this._it._isREPGreater?A[c]:-A[c]),C=g.duration,y=0,[R,N,j,W]=this._utils.getPositions(d,A,{enter:n,leave:u,ref:t,refOpposite:p,length:c}),E=j-R;if(E>0&&(y=C*E/b,this.seek(g,y,f)),!o.boolean(r)){let F=0;clearTimeout(l.snapTimeOutId);let $=setTimeout(()=>{let L=r.to.map(D=>y-D),_=L.map(D=>Math.abs(D)),x=Math.min(..._),G=L[_.indexOf(x)],P=b*x/C,M={snapDistance:P,currentDis:F,snap:r,step:T};if(!(P>=r.maxDistance||P<T)){if(r.onStart(this._it),G<0){this.startSnaping(M);return}this.startSnaping({...M,toRef:!0})}},r.after*1e3);this._utils.setTriggerStates(a,{ids:{...l,snapTimeOutId:$}})}}}animate(t,p,c){let{instance:i,toggleActions:h,link:m,snap:a}=p;if(m){let{animate:s}=this._utils.getTriggerStates(t,"onScroll"),g=this._utils.getTriggerStates(t,"ids"),{enter:r,leave:T,minPosition:f,maxPosition:d}=this._utils.getTriggerData(t),l=this.getTIL(t,f,d),A=this.getSnapStep(a),b={enter:r,leave:T,tIL:l,instance:i,snap:a,link:o.boolean(m)?m:Math.abs(m),step:A};switch(c){case 0:case 2:if(this._it._states.oCbFirstInvoke&&this.animateHandler(t,b),s)break;this._utils.setTriggerScrollStates(t,"animate",()=>this.animateHandler(t,b));break;case 1:case 3:clearTimeout(g.snapTimeOutId),this._utils.setTriggerScrollStates(t,"animate"),this.seek(i,c===1?i.duration:0,m);break}return}let n=h[c],u=i.currentTime/i.duration;if(n!=="none")switch(n){case"play":i.reversed&&(i.reverse(),i.completed=!1),u<1&&i[n]();break;case"resume":u<1&&u>0&&i.play();break;case"restart":case"reset":i.reversed&&i.reverse(),i[n]();break;case"pause":i[n]();break;case"complete":i.pause(),i.seek(i.reversed?0:i.duration);break;case"reverse":!i.reversed&&i[n](),i.paused&&i.play();break;case"kill":o.inObject(i,"kill")&&i.kill(),this._utils.setTriggerData(t,{animation:void 0},!0);break}}parse(t,p){let c={},i={};if(p){let{instance:h,snap:m}=t;!o.boolean(m)&&(i={...t,snap:this.parseSnap({instance:h,snap:m},!0)})}else{if(!o.object(t))return k('"animation" parameter is NOT valid.');if(o.animeInstance(t))c=S(I,{instance:t});else if(t.instance&&o.animeInstance(t.instance))c=S(I,t);else return k('"instance" parameter must be anime instance.');let{toggleActions:h,snap:m,instance:a,link:n}=c;i={instance:a,toggleActions:B(h),snap:!!m&&this.parseSnap({instance:a,snap:m}),link:n}}return i.instance.reset(),i}update(){this._it.triggers.forEach(t=>{let{enter:p,leave:c,minPosition:i,maxPosition:h,animation:m}=this._utils.getTriggerData(t);m=m&&this.parse(m,!0),this._utils.setTriggerData(t,{animation:m},!0);let{animate:a}=this._utils.getTriggerStates(t,"onScroll");if(a&&!!m){let{instance:n,snap:u,link:s}=m,g=this.getTIL(t,i,h),r=this.getSnapStep(u);this._utils.setTriggerScrollStates(t,"animate"),this._utils.setTriggerScrollStates(t,"animate",()=>this.animateHandler(t,{enter:p,leave:c,instance:n,snap:u,link:s,tIL:g,step:r}))}})}kill(){this.killed=!0,this._it=this._utils=void 0}};v.pluginName="animation";var z=v;export{z as default};
//# sourceMappingURL=animation.esm.min.js.map
