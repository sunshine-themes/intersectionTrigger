/*
* IntersectionTrigger v1.0.4 
* IntersectionTrigger utilizes the most modern web technology to trigger anything by intersection. Including scroll-based animations.
* https://sunshine-themes.com/?appID=ss_app_1
*
* Copyright 2023, Sunshine. All rights reserved.
* @license: Released under the personal 'no charge' license can be viewed at http://sunshine-themes.com/?appID=ss_app_1&tab=license, Licensees of commercial or business license are granted additional rights. See http://sunshine-themes.com/?appID=ss_app_1&tab=license for details..
* @author: Sherif Magdy, sherifmagdy@sunshine-themes.com
*
* Released on: January 2, 2023
*/

var B=()=>{};var V=["play","complete","reverse","complete"],D={to:null,after:1,speed:100,maxDistance:500,onStart:B,onComplete:B};var T={instance:null,toggleActions:V,link:!1,snap:!1};var a={function:t=>typeof t=="function",string:t=>typeof t=="string",boolean:t=>typeof t=="boolean",object:t=>t&&typeof t=="object"&&!(t instanceof Array),inObject:(t,s)=>a.object(t)&&s in t,num:t=>typeof t=="number",percent:t=>t&&t.includes("%"),pixel:t=>t&&t.includes("px"),array:t=>t instanceof Array,element:t=>t instanceof HTMLElement||t instanceof Element,doc:t=>t&&t.nodeType===9,scrollable:(t,s=null)=>s?s==="y"?t.scrollHeight>t.clientHeight:t.scrollWidth>t.clientWidth:t.scrollHeight>t.clientHeight||t.scrollWidth>t.clientWidth,anime:t=>a.object(t)&&t.hasOwnProperty("animatables")&&!t.hasOwnProperty("add"),tl:t=>a.object(t)&&t.hasOwnProperty("add")&&a.function(t.add),animeInstance:t=>a.anime(t)||a.tl(t)},L=(t,s,f)=>Math.min(Math.max(t,s),f),C=t=>t.split(/\s+/);var _=(t,s)=>{let f=t,o=s;return Object.entries(f).forEach(([i,g])=>{a.object(g)?_(g,o[i]=o[i]||{}):i in o||(o[i]=g)}),o},j=t=>{throw new Error(t)};var v=class{constructor(s){return this._registerIntersectionTrigger(s),this.setUtils(),this}_registerIntersectionTrigger(s){this._it=s,this._utils=this._it._utils}setUtils(){let{ref:s,refOpposite:f,length:o}=this._utils.dirProps(),i=this._utils.isVertical(),g=this._utils.getRoot(),d=new WeakMap;this.seekSmoothly=(n,e,r,l)=>{if(this.killed)return;let m=n.currentTime,c=l?Math.min(m+r,e):Math.max(m-r,e);if(n.seek(c),l?c>=e:c<=e)return;let u=requestAnimationFrame(()=>this.seekSmoothly(n,e,r,l));d.set(n,u)},this.seek=(n,e,r)=>{if(a.num(r)){let l=n.currentTime,m=e>l,c=d.has(n)&&d.get(n)||0;cancelAnimationFrame(c),this.seekSmoothly(n,e,r,m);return}n.seek(e)},this.startSnaping=({snapDistance:n,currentDis:e,snap:r,step:l,toRef:m=!1})=>{if(this.killed)return;let c=m?-1:1;if(i?g.scrollBy({top:l*c,behavior:"instant"}):g.scrollBy({left:l*c,behavior:"instant"}),e+=l,e>=n){e=0,r.onComplete(this._it);return}requestAnimationFrame(()=>this.startSnaping({snapDistance:n,currentDis:e,snap:r,step:l,toRef:m}))},this.parseSnap=({instance:n,snap:e},r=!1)=>{let l=h=>{let k=[],b=h;for(;b<1;)k.push(L(b,0,1)),b=b+h;return k.map(S=>Math.round(S*n.duration))},m=h=>{if(a.num(h))return l(h);if(a.string(h))return c(h);if(a.array(h))return h},c=()=>{if(!!a.inObject(n,"marks"))return n.marks.map(h=>h.time)},p=(h,k)=>r?h.toOriginal:k,u={};switch(!0){case(a.boolean(e)&&e):!r&&(u.toOriginal="marks"),u.to=c(p(u,e));break;case a.array(e):!r&&(u.toOriginal=e),u.to=p(u,e);break;case a.num(e):!r&&(u.toOriginal=e),u.to=l(p(u,e));break;case a.object(e):u=e,!r&&(u.toOriginal=u.to),u.to=m(p(u,u.to));break}return _(D,u)},this.getTIL=(n,e,r)=>{let l=n.getBoundingClientRect();return l[o]-(e*l[o]+(1-r)*l[o])},this.getSnapStep=n=>n&&Math.round(Math.max(n.speed*17/1e3,1)),this.animateHandler=(n,{enter:e,leave:r,tIL:l,instance:m,snap:c,step:p,link:u})=>{if(this.killed)return;let h=n.getBoundingClientRect(),k=this._utils.getTriggerStates(n,"ids");this._it.rootBounds=this._utils.getRootRect(this._it.observer.rootMargin);let b=this._it.rootBounds,S=l+(this._it._isREPGreater?b[o]:-b[o]),E=m.duration,y=0,[F,q,H,U]=this._utils.getPositions(h,b,{enter:e,leave:r,ref:s,refOpposite:f,length:o}),x=H-F;if(x>0&&(y=E*x/S,this.seek(m,y,u)),c){let W=0;clearTimeout(k.snapTimeOutId);let R=setTimeout(()=>{let I=c.to.map(P=>y-P),M=I.map(P=>Math.abs(P)),A=Math.min(...M),N=I[M.indexOf(A)],O=S*A/E,w={snapDistance:O,currentDis:W,snap:c,step:p};if(!(O>=c.maxDistance||O<p)){if(c.onStart(this._it),N<0){this.startSnaping(w);return}this.startSnaping({...w,toRef:!0})}},c.after*1e3);this._utils.setTriggerStates(n,{ids:{...k,snapTimeOutId:R}})}}}animate(s,f,o){let{instance:i,toggleActions:g,link:d,snap:n}=f;if(!i)return;if(d){let{animate:l}=this._utils.getTriggerStates(s,"onScroll"),m=this._utils.getTriggerStates(s,"ids"),{enter:c,leave:p,minPosition:u,maxPosition:h}=this._utils.getTriggerData(s),k=this.getTIL(s,u,h),b=this.getSnapStep(n)||0,S={enter:c,leave:p,tIL:k,instance:i,snap:n,link:a.boolean(d)?d:Math.abs(d),step:b};switch(o){case 0:case 2:if(this._it._states.oCbFirstInvoke&&this.animateHandler(s,S),l)break;this._utils.setTriggerScrollStates(s,"animate",()=>this.animateHandler(s,S));break;case 1:case 3:clearTimeout(m.snapTimeOutId),this._utils.setTriggerScrollStates(s,"animate",null),this.seek(i,o===1?i.duration:0,d);break}return}let e=g[o],r=i.currentTime/i.duration;if(e!=="none")switch(e){case"play":i.reversed&&(i.reverse(),i.completed=!1),r<1&&i[e]();break;case"resume":r<1&&r>0&&i.play();break;case"restart":case"reset":i.reversed&&i.reverse(),i[e]();break;case"pause":i[e]();break;case"complete":i.pause(),i.seek(i.reversed?0:i.duration);break;case"reverse":!i.reversed&&i[e](),i.paused&&i.play();break;case"kill":a.inObject(i,"kill")&&i.kill(),this._utils.setTriggerData(s,null,{animation:{...T}});break}}parse(s,f=!1){let o={};switch(!0){case a.animeInstance(s):o=_(T,{instance:s});break;case a.object(s):{o=_(T,s);let{toggleActions:i,snap:g,instance:d}=o;g&&(o.snap=this.parseSnap({instance:d,snap:g},f)),a.string(i)&&(o.toggleActions=C(i))}break}return!a.animeInstance(o.instance)&&j("Invalid anime instance"),a.inObject(o,"instance")&&o.instance.reset(),o}update(){this._it.triggers.forEach(s=>{let{enter:f,leave:o,minPosition:i,maxPosition:g,animation:d}=this._utils.getTriggerData(s);d=this.parse(d,!0),this._utils.setTriggerData(s,null,{animation:d});let{animate:n}=this._utils.getTriggerStates(s,"onScroll");if(n){let{instance:e,snap:r,link:l}=d,m=this.getTIL(s,i,g),c=this.getSnapStep(r)||0;this._utils.setTriggerScrollStates(s,"animate",null),this._utils.setTriggerScrollStates(s,"animate",()=>this.animateHandler(s,{enter:f,leave:o,instance:e,snap:r,link:l,tIL:m,step:c}))}})}kill(){this.killed=!0,this._it=null,this._utils=null}};v.pluginName="animation";var K=v;export{K as default};
//# sourceMappingURL=animation.esm.min.js.map
