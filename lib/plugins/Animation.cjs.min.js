/*
* Animation v1.0.0
* https://sunshine-themes.com/intersectionTrigger
*
* @license Copyright 2022, Sunshine. All rights reserved.
* Subject to the terms at https://sunshine-themes.com/intersectionTrigger/standard-licensew.
* @author: Sherif magdy, sherifmagdy@sunshine-themes.com
*/
                  
var L=Object.defineProperty;var tt=t=>L(t,"__esModule",{value:!0});var et=(t,e)=>{for(var n in e)L(t,n,{get:e[n],enumerable:!0})};tt(exports);et(exports,{default:()=>F});var D=()=>{};var st=["play","complete","reverse","complete"],I={to:null,after:1,speed:100,maxDistance:500,onStart:D,onComplete:D};var S={instance:null,toggleActions:st,control:!1,snap:!1};var o={function:t=>typeof t=="function",string:t=>typeof t=="string",boolean:t=>typeof t=="boolean",object:t=>t&&typeof t=="object"&&!(t instanceof Array),inObject:(t,e)=>o.object(t)&&e in t,num:t=>typeof t=="number",percent:t=>t&&t.includes("%"),pixel:t=>t&&t.includes("px"),array:t=>t instanceof Array,element:t=>t instanceof HTMLElement||t instanceof Element,doc:t=>t&&t.nodeType===9,scrollable:(t,e=null)=>e?e==="y"?t.scrollHeight>t.clientHeight:t.scrollWidth>t.clientWidth:t.scrollHeight>t.clientHeight||t.scrollWidth>t.clientWidth,anime:t=>o.object(t)&&t.hasOwnProperty("animatables")&&!t.hasOwnProperty("add"),tl:t=>o.object(t)&&t.hasOwnProperty("add")&&o.function(t.add),animeInstance:t=>o.anime(t)||o.tl(t)},R=(t,e,n)=>Math.min(Math.max(t,e),n),H=t=>t.split(/\s+/);var g=(t,e)=>{let n=t,a=e;return Object.entries(n).forEach(([s,l])=>{o.object(l)?g(l,a[s]=a[s]||{}):s in a||(a[s]=l)}),a},W=t=>{throw new Error(t)};var F=class{constructor(e){return this._registerIntersectionTrigger(e),this}_registerIntersectionTrigger(e){this._it=e,this._utils=this._it._utils}animate(e,n,a){let{instance:s,toggleActions:l,control:i,snap:r}=n;if(!s)return;if(i){let{animate:u}=this._utils.getTriggerStates(e,"onScroll"),y=this._utils.getTriggerStates(e,"ids"),{enter:N,leave:V,minPosition:q,maxPosition:G}=this._utils.getTriggerData(e),{ref:$,refOpposite:z,length:p}=this._utils.dirProps(),J=this._utils.isVirtical(),P=e.getBoundingClientRect(),K=P[p]-(q*P[p]+(1-G)*P[p]),M=this._utils.getRoot(),O=s.duration,b=h=>s.seek(h),w=h=>{let Q=h.getBoundingClientRect(),j=this._utils.getTriggerStates(h,"ids");this._it.rootBounds=this._utils.getRootRect(this._it.observer.rootMargin);let E=this._it.rootBounds,A=K+(this._it._isREPGreater?E[p]:-E[p]),_=0,[U,nt,X,ot]=this._utils.getPositions(Q,E,{enter:N,leave:V,ref:$,refOpposite:z,length:p}),C=X-U;if(C>0&&(_=O*C/A,o.num(i)?setTimeout(()=>b(_),i*1e3):b(_)),r){let k=Math.round(Math.max(r.speed*17/1e3,1)),v=0,x=(d,m=!1)=>{let f=m?-1:1;if(J?M.scrollBy({top:k*f,behavior:"instant"}):M.scrollBy({left:k*f,behavior:"instant"}),v+=k,v>=d){v=0,r.onComplete(this._it);return}requestAnimationFrame(()=>x(d,m))};clearTimeout(j.snapTimeOutId);let Y=setTimeout(()=>{let d=r.to.map(B=>_-B),m=d.map(B=>Math.abs(B)),f=Math.min(...m),Z=d[m.indexOf(f)],T=A*f/O;if(!(T>=r.maxDistance||T<k)){if(r.onStart(this._it),Z<0){x(T);return}x(T,!0)}},r.after*1e3);this._utils.setTriggerStates(h,{ids:{...j,snapTimeOutId:Y}})}};switch(a){case 0:case 2:if(this._it._states.oCbFirstInvoke&&w(e),u)break;this._utils.setTriggerScrollStates(e,"animate",w);break;case 1:case 3:if(clearTimeout(y.snapTimeOutId),this._utils.setTriggerScrollStates(e,"animate",null),a===1){b(O);break}b(0);break}return}let c=l[a];if(c!=="none")switch(c){case"play":s.reversed&&s.reverse(),1>s.progress&&s[c]();break;case"restart":case"reset":s.reversed&&s.reverse(),s[c]();break;case"pause":s[c]();break;case"complete":s.pause(),s.seek(s.reversed?0:s.duration);break;case"reverse":if(s.reversed)break;s[c](),s.paused&&s.play();break;case"kill":o.inObject(s,"kill")&&s.kill(),this._utils.setTriggerData(e,null,{animation:{...S}});break}}parse(e){let n={};switch(!0){case o.animeInstance(e):n=g(S,{instance:e});break;case o.object(e):{this._params=g(S,e),o.animeInstance(this._params.instance)||W("Invalid anime instance");let{toggleActions:a,snap:s}=this._params;s&&this.parseSnap(),o.string(a)&&(this._params.toggleActions=H(a)),n=this._params}break}return o.inObject(n,"instance")&&n.instance.reset(),n}parseSnap(){let{instance:e,snap:n}=this._params,a=r=>{let c=[],u=r;for(;u<1;)c.push(R(u,0,1)),u=u+r;return c.map(y=>Math.round(y*e.duration))},s=r=>{if(o.num(r))return a(r);if(o.string(r))return l(r);if(o.array(r))return r},l=()=>o.inObject(e,"marks")?e.marks.map(u=>u.time):void 0,i={};switch(!0){case(o.boolean(n)&&n):i.to=l(n);break;case o.array(n):i.to=n;break;case o.num(n):i.to=a(n);break;case o.object(n):i=n,i.to=s(i.to);break}this._params.snap=g(I,i)}kill(){this._it=null,this._utils=null}};
