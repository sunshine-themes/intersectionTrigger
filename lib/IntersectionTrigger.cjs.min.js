/*
* IntersectionTrigger v1.0.0
* https://sunshine-themes.com/intersectionTrigger
*
* @license Copyright 2022, Sunshine. All rights reserved.
* Subject to the terms at https://sunshine-themes.com/intersectionTrigger/standard-licensew.
* @author: Sherif magdy, sherifmagdy@sunshine-themes.com
*/
                  
var O=Object.defineProperty;var K=r=>O(r,"__esModule",{value:!0});var X=(r,t)=>{for(var i in t)O(r,i,{get:t[i],enumerable:!0})};K(exports);X(exports,{default:()=>L});var P=()=>{},Y=["add","remove","add","remove"],Z=["play","finish","reverse","finish"],A={defaults:{once:!1,onEnter:P,onLeave:P,onEnterBack:P,onLeaveBack:P,toggleClass:null,animation:null},enter:"0% 100%",leave:"100% 0%",axis:"y",name:"",root:null,onScroll:P},M={hasEntered:!1,hasEnteredBack:!1,hasLeft:!0,hasLeftBack:!0,hasEnteredOnce:!1,onScroll:{backup:null,animate:null}};var w={targets:null,toggleActions:Y,classNames:null},x={instance:null,toggleActions:Z,control:!1};var c={function:r=>typeof r=="function",string:r=>typeof r=="string",boolean:r=>typeof r=="boolean",object:r=>r&&typeof r=="object"&&!(r instanceof Array),inObject:(r,t)=>c.object(r)&&t in r,num:r=>typeof r=="number",percent:r=>r&&r.includes("%"),pixel:r=>r&&r.includes("px"),array:r=>r instanceof Array,element:r=>r instanceof HTMLElement||r instanceof Element,doc:r=>r&&r.nodeType===9,scrollable:(r,t=null)=>t?t==="y"?r.scrollHeight>r.clientHeight:r.scrollWidth>r.clientWidth:r.scrollHeight>r.clientHeight||r.scrollWidth>r.clientWidth,anime:r=>c.object(r)&&r.hasOwnProperty("animatables")&&!r.hasOwnProperty("add"),tl:r=>c.object(r)&&r.hasOwnProperty("add")&&c.function(r.add),animeInstance:r=>c.anime(r)||c.tl(r)},E=r=>r.split(/\s+/),H=(r,t)=>r&&r.getBoundingClientRect()[t],V=(r,t)=>t==="y"?r.scrollHeight:r.scrollWidth,v=(r,t)=>{c.string(r)&&(r=parseFloat(r));let i=Math.pow(10,t||0);return Math.round(r*i)/i};var d=(r,t)=>{let i=r,s=t;return Object.entries(i).forEach(([e,o])=>{c.object(o)?d(o,s[e]=s[e]||{}):e in s||(s[e]=o)}),s},m=r=>{throw new Error(r)},F=r=>{let t=r.getBoundingClientRect(),{top:i,bottom:s,right:e,left:o,height:a,width:n,x:l,y:h}=t;return{top:i,left:o,height:a,width:n,x:l,y:h,right:e-(e-o-r.clientWidth),bottom:s-(s-i-r.clientHeight)}};var y=class{constructor(t){return this._it=t,this.setUtils(),this}setUtils(){this.isVirtical=()=>this._it.axis==="y",this.isRootViewport=()=>!this._it._root,this.getRoot=()=>this._it._root??window,this.dirProps=()=>this.isVirtical()?{ref:"top",length:"height",refOpposite:"bottom",innerLength:innerHeight}:{ref:"left",length:"width",refOpposite:"right",innerLength:innerWidth},this.setRootMargin=()=>{let t=V(this.isRootViewport()?document.body:this._it._root,this.isVirtical()?"x":"y");return this.isVirtical()?`${this._it._positions.rootLeavePosition.strValue} ${t}px ${this._it._positions.rootEnterPosition.strValue} ${t}px`:`${t}px ${this._it._positions.rootEnterPosition.strValue} ${t}px ${this._it._positions.rootLeavePosition.strValue}`},this.setThreshold=()=>{let t=[0,this._it._triggerParams.enter,this._it._triggerParams.leave,v(1-this._it._triggerParams.leave,2),1];return this._it.triggers.forEach(i=>{let{enter:s,leave:e}=this.getTriggerData(i);t.push(s,e,v(1-e,2))}),[...new Set(t)]},this.parseQuery=(t,i)=>{switch(!0){case c.string(t):return[...document.querySelectorAll(t)];case c.array(t):return t;case c.element(t):return[t];default:m(`${i} parameter must be a valid selector, an element or array of elements`)}},this.customParseQuery=(t,i="trigger")=>{let s=i==="trigger",e=s?[]:{};return s?this.parseQuery(t,"trigger"):(e=c.string(t)?document.querySelector(t):c.element(t)?t:m("root parameter must be a valid selector or an element"),e)},this.validatePosition=(t,i)=>(c.function(i)&&(i=i(this._it)),c.string(i)||m(`${t} parameter must be a string.`),i),this.setPositionData=(t,i=!0,s=!0)=>{t=this.validatePosition(s?"enter":"leave",t);let e=t.trim(),o=c.percent(e),a=c.pixel(e),n={};if(e=o?e.replace("%",""):a?e.replace("px",""):e,e=v(e),n.type=o?"percent":"pixel",o&&i)return n.value=e/100,n.strValue=`${e}%`,n;let{length:l,innerLength:h}=this.dirProps(),u=this._it._root?H(this._it._root,l):h;switch(!0){case(o&&s):n.value=v(e/100-1,2),n.strValue=`${n.value*100}%`;break;case(o&&!s):n.value=-e/100,n.strValue=`${n.value*100}%`;break;case(a&&s):n.value=v(e-u,2),n.strValue=`${n.value}px`;break;case(a&&!s):n.value=-e,n.strValue=`${-e}px`;break}return n.guide=t,n},this.parsePositions=(t="",i="")=>{t=this.validatePosition("enter",t),i=this.validatePosition("leave",i);let s=t.trim().split(/\s+/g,2),e=i.trim().split(/\s+/g,2),o=[...s,...e];return{triggerEnterPosition:this.setPositionData(o[0]),rootEnterPosition:this.setPositionData(o[1],!1),triggerLeavePosition:this.setPositionData(o[2]),rootLeavePosition:this.setPositionData(o[3],!1,!1)}},this.deleteTriggerData=t=>{this._it._triggersData.delete(t)},this.hasTriggerData=(t,i=null)=>{let s=this._it._triggersData.has(t);return i?s&&i in this.getTriggerData(t):s},this.getTriggerData=(t,i=null)=>i?this.hasTriggerData(t,i)?this._it._triggersData.get(t)[i]:{}:this.hasTriggerData(t)&&this._it._triggersData.get(t)||{},this.setTriggerData=(t,i,s=null)=>{if(s){let e=this.getTriggerData(t);c.object(e)&&this._it._triggersData.set(t,{...e,...s});return}this._it._triggersData.set(t,i)},this.getTriggerStates=(t,i=null)=>{let s=this.getTriggerData(t,"states"),e=s.hasEntered||s.hasEnteredBack;return i?s[i]:{...s,hasEnteredFromOneSide:e}},this.setTriggerStates=(t,i={})=>{let s=this.getTriggerData(t),e=s&&{...s.states,...i};this.setTriggerData(t,null,{states:e})},this.setTriggerScrollStates=(t,i,s=null)=>{let e=this.getTriggerStates(t,"onScroll");if(e[i]=s,this.setTriggerStates(t,{onscroll:{...e}}),s){this._it._states.runningScrollCbs===0&&this._it.addScrollListener(this._it._onScrollHandler),this._it._states.runningScrollCbs++;return}0<this._it._states.runningScrollCbs&&this._it._states.runningScrollCbs--,this._it._states.runningScrollCbs===0&&this._it.removeScrollListener(this._it._onScrollHandler)},this.onTriggerEnter=(t,i="Enter")=>{let{hasEnteredOnce:s}=this.getTriggerStates(t),{onEnter:e,onEnterBack:o,toggleClass:a,animation:n}=this.getTriggerData(t),l=i==="Enter",h={callback:l?e:o,enterProp:l?"hasEntered":"hasEnteredBack",leaveProp:l?"hasLeftBack":"hasLeft",eventIndex:l?0:2};h.callback(t,this),a&&this.toggleClass(t,a,h.eventIndex),n&&this.animate(t,n,h.eventIndex);let u=s?{[h.enterProp]:!0,[h.leaveProp]:!1}:{[h.enterProp]:!0,hasLeft:!1,hasLeftBack:!1};this.setTriggerStates(t,u),s||this.setTriggerStates(t,{hasEnteredOnce:!0})},this.onTriggerLeave=(t,i="Leave")=>{let{once:s}=this.getTriggerData(t),{hasEnteredOnce:e}=this.getTriggerStates(t),{onLeave:o,onLeaveBack:a,toggleClass:n,animation:l}=this.getTriggerData(t),h=i==="Leave",u={callback:h?o:a,leaveProp:h?"hasLeft":"hasLeftBack",eventIndex:h?1:3};u.callback(t,this),n&&this.toggleClass(t,n,u.eventIndex),l&&this.animate(t,l,u.eventIndex),this.setTriggerStates(t,{[u.leaveProp]:!0,hasEntered:!1,hasEnteredBack:!1}),s&&e&&this._it.remove(t)},this.animate=(t,i,s)=>{let{instance:e,toggleActions:o,control:a}=i;if(!e)return;if(a){let{animate:l}=this.getTriggerStates(t,"onScroll"),{enter:h,leave:u}=this.getTriggerData(t),{ref:g,refOpposite:b,length:_}=this.dirProps(),p=t.getBoundingClientRect(),f=p[_]-(h*p[_]+(1-u)*p[_]),B=e.duration,I=C=>{let R=C.getBoundingClientRect();this._it.rootBounds=this.getRootRect(this._it.observer.rootMargin);let D=this._it.rootBounds,T=D[b]-(R[g]+h*R[_]);if(T>0){let k=B*T/(f+D[_]);if(c.num(a)){setTimeout(()=>e.seek(k),a*1e3);return}e.seek(k)}};switch(s){case 0:case 2:if(this._it._states.oCbFirstInvoke&&I(t),l)break;this.setTriggerScrollStates(t,"animate",I);break;case 1:case 3:this.setTriggerScrollStates(t,"animate",null);break}return}let n=o[s];if(n!=="none")switch(n){case"play":e.reversed&&e.reverse(),1>e.progress&&e[n]();break;case"restart":case"reset":e.reversed&&e.reverse(),e[n]();break;case"pause":break;case"finish":e.pause(),e.seek(e.reversed?0:e.duration);break;case"reverse":if(e.reversed)break;e[n](),e.paused&&e.play();break;case"kill":c.inObject(e,"kill")&&e.kill(),this.setTriggerData(t,null,{animation:{...x}});break}},this.parseAnimation=t=>{let i={};switch(!0){case c.animeInstance(t):i=d(x,{instance:t});break;case c.object(t):{let s=d(x,t),{toggleActions:e}=s;c.string(e)&&(s.toggleActions=E(e)),i=s}break}return c.inObject(i,"instance")&&i.instance.reset(),i},this.toggleClass=(t,i,s)=>{for(let{targets:e,toggleActions:o,classNames:a}of i)o[s]!=="none"&&a.forEach(n=>e.forEach(l=>l==="trigger"?t.classList[o[s]](n):l.classList[o[s]](n)))},this.parseToggleClass=t=>{let i=[];if(c.string(t)){let s=d(w,{targets:["trigger"],classNames:E(t)});return i.push([s]),i}return c.array(t)&&(i=t.map(s=>{let e=d(w,s),{targets:o,classNames:a,toggleActions:n}=e;return o&&(e.targets=this.parseQuery(o,"targets")),a&&(e.classNames=E(a)),c.string(n)&&(e.toggleActions=E(n)),e})),i},this.toggleActions=t=>{let i=t.getBoundingClientRect();this._it.rootBounds=this.getRootRect(this._it.observer.rootMargin);let s=this._it.rootBounds,{enter:e,leave:o}=this.getTriggerData(t),{hasEnteredFromOneSide:a,hasLeft:n,hasLeftBack:l}=this.getTriggerStates(t),{ref:h,refOpposite:u,length:g}=this.dirProps(),b=!0;switch(!0){case(l&&i[h]+e*i[g]<=s[u]&&i[h]+e*i[g]>s[h]):this.onTriggerEnter(t);break;case(a&&i[h]+o*i[g]<=s[h]):this.onTriggerLeave(t);break;case(n&&i[h]+o*i[g]>=s[h]&&i[h]+o*i[g]<s[u]):this.onTriggerEnter(t,"EnterBack");break;case(a&&i[h]+e*i[g]>=s[u]):this.onTriggerLeave(t,"hasLeftBack");break;default:b=!1;break}return b},this.parseString=t=>t.split(/\s+/).map(s=>{let e=/^(-?\d*\.?\d+)(px|%)$/.exec(s);return{value:parseFloat(e[1]),unit:e[2]}}),this.parseRootMargin=t=>{var i=t||"0px",s=this.parseString(i);return s[1]=s[1]||s[0],s[2]=s[2]||s[0],s[3]=s[3]||s[1],s},this.expandRectByRootMargin=(t,i)=>{let s=this.parseRootMargin(i).map((o,a)=>o.unit=="px"?o.value:o.value*(a%2?t.width:t.height)/100),e={top:t.top-s[0],right:t.right+s[1],bottom:t.bottom+s[2],left:t.left-s[3]};return e.width=e.right-e.left,e.height=e.bottom-e.top,e},this.getRootRect=t=>{let i;if(this._it._root&&!c.doc(this._it._root))return i=F(this._it._root),this.expandRectByRootMargin(i,t);let s=c.doc(this._it._root)?this._it._root:document,e=s.documentElement,o=s.body;return i={top:0,left:0,right:e.clientWidth||o.clientWidth,width:e.clientWidth||o.clientWidth,bottom:e.clientHeight||o.clientHeight,height:e.clientHeight||o.clientHeight},this.expandRectByRootMargin(i,t)}}},$=y;var S=[],j=0,L=class{constructor(t={}){this._userOptions=t,this.triggers=[],this._triggersData=new WeakMap,this._guidesInstance=null,this._utils=new $(this),this.id=j,j++,S.push(this),this._setStates(),this._setInstance()}_setStates(){this._states={},this._states.oCbFirstInvoke=!0,this._states.runningScrollCbs=0}_rAFCallback=t=>{this.triggers.forEach(i=>{let s=this._utils.getTriggerStates(i,"onScroll");for(let e in s)s[e]&&s[e](i,t)})};_onScrollHandler=()=>requestAnimationFrame(this._rAFCallback);addScrollListener(t){this._utils.getRoot().addEventListener("scroll",t,!1)}removeScrollListener(t){this._utils.getRoot().removeEventListener("scroll",t,!1)}_createInstance(){this._threshold=this._utils.setThreshold(),this._observerOptions={root:this._root,rootMargin:this._rootMargin,threshold:this._threshold},this.observer=new IntersectionObserver(this._observerCallback,this._observerOptions),this._root=this.observer.root,this.rootBounds=this._utils.getRootRect(this.observer.rootMargin),this._isRootViewport=this._utils.isRootViewport()}_observerCallback=(t,i)=>{let{ref:s,refOpposite:e,length:o}=this._utils.dirProps();for(let a of t){let n=a.target,l=a.boundingClientRect,h=a.isIntersecting,u=a.intersectionRatio;this.rootBounds=a.rootBounds||this._utils.getRootRect(i.rootMargin);let g=this.rootBounds,b=g[o],_=b/l[o],{enter:p,leave:f}=this._utils.getTriggerData(n),{hasEnteredFromOneSide:B,onScroll:{backup:I}}=this._utils.getTriggerStates(n),C=l[o]>=b,R=p>_,D=1-f>_,T=C&&(R||D),k=!!I,W=l[s]+p*l[o]<g[e]&&l[s]+p*l[o]>g[s],Q=l[s]+f*l[o]<g[e]&&l[s]+f*l[o]>g[s],U=l[s]+p*l[o]<g[s],N=l[s]+f*l[o]>g[e],G=l[s]+f*l[o]<g[s]&&u<1-f,z=l[s]<g[s],J=l[e]<g[s];switch(!0){case this._states.oCbFirstInvoke:switch(!0){case(!h&&z&&J):this._utils.onTriggerEnter(n),this._utils.onTriggerLeave(n);break;case h:switch(!0){case(W||Q||U&&N):this._utils.onTriggerEnter(n);break;case G:this._utils.onTriggerEnter(n),this._utils.onTriggerLeave(n);break}T&&this._utils.setTriggerScrollStates(n,"backup",this._utils.toggleActions);break}break;case!h:switch(k&&this._utils.setTriggerScrollStates(n,"backup",null),!0){case(B&&l[e]<g[s]):this._utils.onTriggerLeave(n);break;case(B&&l[s]>g[e]):this._utils.onTriggerLeave(n,"onLeaveBack");break}break;case(h&&!k):this._utils.toggleActions(n),T&&this._utils.setTriggerScrollStates(n,"backup",this._utils.toggleActions);break}}this._states.oCbFirstInvoke=!1};_setInstance(){this._defaultOptions=A,this._options=d(this._defaultOptions,this._userOptions),this.axis=c.string(this._options.axis)?this._options.axis:m("axis parameter must be a string."),this.name=c.string(this._options.name)?this._options.name:m("name parameter must be a string."),this._root=!!this._options.root&&this._utils.customParseQuery(this._options.root,"root")||null,this._positions=this._utils.parsePositions(this._options.enter,this._options.leave),this.customScrollHandler=this._options.onScroll;let{once:t,onEnter:i,onLeave:s,onEnterBack:e,onLeaveBack:o,toggleClass:a,animation:n}=this._options.defaults;return this._triggerParams={enter:this._positions.triggerEnterPosition.value,leave:this._positions.triggerLeavePosition.value,once:t,onEnter:i,onLeave:s,onEnterBack:e,onLeaveBack:o,toggleClass:a,animation:n},this._rootMargin=this._utils.setRootMargin(),this._createInstance(),this.customScrollHandler&&this.addScrollListener(this.customScrollHandler),this}add(t={},i={}){let s=this._utils.customParseQuery(t);"enter"in i&&(i.enter=this._utils.setPositionData(i.enter).value),"leave"in i&&(i.leave=this._utils.setPositionData(i.leave).value);let e={...d(this._triggerParams,i),states:{...M}};e.toggleClass&&(e.toggleClass=this._utils.parseToggleClass(e.toggleClass)),e.animation&&(e.animation=this._utils.parseAnimation(e.animation)),this.triggers=[...new Set([...this.triggers,...s])];let o=!1;return[i.enter,i.leave].forEach(a=>!this._threshold.some(n=>a===n)&&(o=!0)),o?(this._disconnect(),s.forEach(a=>this._utils.setTriggerData(a,e)),this._createInstance(),this.triggers.forEach(a=>this.observer.observe(a))):s.forEach(a=>{this._utils.setTriggerData(a,e),this.observer.observe(a)}),this._guidesInstance&&this._guidesInstance.refresh(),this}remove(t={}){let i=this._utils.customParseQuery(t);i.forEach(e=>{this._utils.deleteTriggerData(e),this.observer.unobserve(e)});let s=this.triggers.filter(e=>!i.some(a=>e===a));return this.triggers=s,this._guidesInstance&&this._guidesInstance.refresh(),this}_disconnect(){this.observer&&this.observer.disconnect(),this.observer=null}kill(){this._disconnect(),this.removeScrollListener(this.customScrollHandler),this.triggers=[],this.removeGuides();let t=S.indexOf(this);~t&&S.splice(t,1)}addGuides(t){return c.inObject(t,"_registerIntersectionTrigger")||m("Invalid Guides Instance."),t._registerIntersectionTrigger(this),t.refresh(),this._guidesInstance=t,this}removeGuides(){return this._guidesInstance&&this._guidesInstance.kill(),this._guidesInstance=null,this}update(){this._guidesInstance&&this._guidesInstance.refresh()}};L.getInstances=()=>S;L.getInstanceById=r=>S.find(t=>t.id===r);L.update=()=>S.forEach(r=>r.update());
