/*
* IntersectionTrigger v1.0.0
* https://sunshine-themes.com/intersectionTrigger
*
* @license Copyright 2022, Sunshine. All rights reserved.
* Subject to the terms at https://sunshine-themes.com/intersectionTrigger/standard-licensew.
* @author: Sherif magdy, sherifmagdy@sunshine-themes.com
*/
                  
var I=Object.defineProperty;var J=r=>I(r,"__esModule",{value:!0});var K=(r,t)=>{for(var s in t)I(r,s,{get:t[s],enumerable:!0})};J(exports);K(exports,{default:()=>d});var b=()=>{};var R={defaults:{once:!1,onEnter:b,onLeave:b,onEnterBack:b,onLeaveBack:b,toggleClass:null,animation:null},enter:"0% 100%",leave:"100% 0%",axis:"y",name:"",root:null,onScroll:b},D={hasEntered:!1,hasEnteredBack:!1,hasLeft:!0,hasLeftBack:!0,hasEnteredOnce:!1,onScroll:{backup:null,animate:null},ids:{snapTimeOutId:0}};var c={function:r=>typeof r=="function",string:r=>typeof r=="string",boolean:r=>typeof r=="boolean",object:r=>r&&typeof r=="object"&&!(r instanceof Array),inObject:(r,t)=>c.object(r)&&t in r,num:r=>typeof r=="number",percent:r=>r&&r.includes("%"),pixel:r=>r&&r.includes("px"),array:r=>r instanceof Array,element:r=>r instanceof HTMLElement||r instanceof Element,doc:r=>r&&r.nodeType===9,scrollable:(r,t=null)=>t?t==="y"?r.scrollHeight>r.clientHeight:r.scrollWidth>r.clientWidth:r.scrollHeight>r.clientHeight||r.scrollWidth>r.clientWidth,anime:r=>c.object(r)&&r.hasOwnProperty("animatables")&&!r.hasOwnProperty("add"),tl:r=>c.object(r)&&r.hasOwnProperty("add")&&c.function(r.add),animeInstance:r=>c.anime(r)||c.tl(r)};var B=(r,t)=>r&&r.getBoundingClientRect()[t],w=(r,t)=>t==="y"?r.scrollHeight:r.scrollWidth,f=(r,t)=>{c.string(r)&&(r=parseFloat(r));let s=Math.pow(10,t||0);return Math.round(r*s)/s};var P=(r,t)=>{let s=r,e=t;return Object.entries(s).forEach(([i,o])=>{c.object(o)?P(o,e[i]=e[i]||{}):i in e||(e[i]=o)}),e},_=r=>{throw new Error(r)},C=r=>{let t=r.getBoundingClientRect(),{top:s,bottom:e,right:i,left:o,height:a,width:n,x:l,y:h}=t;return{top:s,left:o,height:a,width:n,x:l,y:h,right:i-(i-o-r.clientWidth),bottom:e-(e-s-r.clientHeight)}},y=r=>r.split(/\s+/).map(s=>{let e=/^(-?\d*\.?\d+)(px|%)$/.exec(s);return{value:parseFloat(e[1]),unit:e[2]}});var T=class{constructor(t){return this._it=t,this.setUtils(),this}setUtils(){this.isVirtical=()=>this._it.axis==="y",this.isRootViewport=()=>!this._it._root,this.getRoot=()=>this._it._root??window,this.dirProps=()=>this.isVirtical()?{ref:"top",length:"height",refOpposite:"bottom",innerLength:innerHeight}:{ref:"left",length:"width",refOpposite:"right",innerLength:innerWidth},this.setRootMargin=()=>{let t=w(this.isRootViewport()?document.body:this._it._root,this.isVirtical()?"x":"y");return this.isVirtical()?`${this._it._positions.rootLeavePosition.strValue} ${t}px ${this._it._positions.rootEnterPosition.strValue} ${t}px`:`${t}px ${this._it._positions.rootEnterPosition.strValue} ${t}px ${this._it._positions.rootLeavePosition.strValue}`},this.setThreshold=()=>{let t=[0,this._it._triggerParams.enter,this._it._triggerParams.leave,f(1-this._it._triggerParams.leave,2),1];return this._it.triggers.forEach(s=>{let{enter:e,leave:i}=this.getTriggerData(s);t.push(e,i,f(1-i,2))}),[...new Set(t)]},this.parseQuery=(t,s)=>{switch(!0){case c.string(t):return[...document.querySelectorAll(t)];case c.array(t):return t;case c.element(t):return[t];default:_(`${s} parameter must be a valid selector, an element or array of elements`)}},this.customParseQuery=(t,s="trigger")=>{let e=s==="trigger",i=e?[]:{};return e?this.parseQuery(t,"trigger"):(i=c.string(t)?document.querySelector(t):c.element(t)?t:_("root parameter must be a valid selector or an element"),i)},this.validatePosition=(t,s)=>(c.function(s)&&(s=s(this._it)),c.string(s)||_(`${t} parameter must be a string.`),s),this.setPositionData=(t,s=!0,e=!0)=>{t=this.validatePosition(e?"enter":"leave",t);let i=t.trim(),o=c.percent(i),a=c.pixel(i),n={};if(i=o?i.replace("%",""):a?i.replace("px",""):i,i=f(i),n.type=o?"percent":"pixel",o&&s)return n.value=i/100,n.strValue=`${i}%`,n;let{length:l,innerLength:h}=this.dirProps(),u=this._it._root?B(this._it._root,l):h;switch(!0){case(o&&e):n.value=f(i/100-1,2),n.strValue=`${n.value*100}%`;break;case(o&&!e):n.value=-i/100,n.strValue=`${n.value*100}%`;break;case(a&&e):n.value=f(i-u,2),n.strValue=`${n.value}px`;break;case(a&&!e):n.value=-i,n.strValue=`${-i}px`;break}return n.guide=t,n},this.parsePositions=(t="",s="")=>{t=this.validatePosition("enter",t),s=this.validatePosition("leave",s);let e=t.trim().split(/\s+/g,2),i=s.trim().split(/\s+/g,2),o=[...e,...i];return{triggerEnterPosition:this.setPositionData(o[0]),rootEnterPosition:this.setPositionData(o[1],!1),triggerLeavePosition:this.setPositionData(o[2]),rootLeavePosition:this.setPositionData(o[3],!1,!1)}},this.deleteTriggerData=t=>{this._it._triggersData.delete(t)},this.hasTriggerData=(t,s=null)=>{let e=this._it._triggersData.has(t);return s?e&&s in this.getTriggerData(t):e},this.getTriggerData=(t,s=null)=>s?this.hasTriggerData(t,s)?this._it._triggersData.get(t)[s]:{}:this.hasTriggerData(t)&&this._it._triggersData.get(t)||{},this.setTriggerData=(t,s,e=null)=>{if(e){let i=this.getTriggerData(t);c.object(i)&&this._it._triggersData.set(t,{...i,...e});return}this._it._triggersData.set(t,s)},this.getTriggerStates=(t,s=null)=>{let e=this.getTriggerData(t,"states"),i=e.hasEntered||e.hasEnteredBack;return s?e[s]:{...e,hasEnteredFromOneSide:i}},this.setTriggerStates=(t,s={})=>{let e=this.getTriggerData(t),i=e&&{...e.states,...s};this.setTriggerData(t,null,{states:i})},this.setTriggerScrollStates=(t,s,e=null)=>{let i=this.getTriggerStates(t,"onScroll");if(i[s]=e,this.setTriggerStates(t,{onscroll:{...i}}),e){this._it._states.runningScrollCbs===0&&this._it.addScrollListener(this._it._onScrollHandler),this._it._states.runningScrollCbs++;return}0<this._it._states.runningScrollCbs&&this._it._states.runningScrollCbs--,this._it._states.runningScrollCbs===0&&this._it.removeScrollListener(this._it._onScrollHandler)},this.onTriggerEnter=(t,s="Enter")=>{let{hasEnteredOnce:e}=this.getTriggerStates(t),{onEnter:i,onEnterBack:o,toggleClass:a,animation:n}=this.getTriggerData(t),l=s==="Enter",h={callback:l?i:o,enterProp:l?"hasEntered":"hasEnteredBack",leaveProp:l?"hasLeftBack":"hasLeft",eventIndex:l?0:2};h.callback(t,this),a&&this._it.toggleClass.toggle(t,a,h.eventIndex),n&&this._it.animation.animate(t,n,h.eventIndex);let u=e?{[h.enterProp]:!0,[h.leaveProp]:!1}:{[h.enterProp]:!0,hasLeft:!1,hasLeftBack:!1};this.setTriggerStates(t,u),e||this.setTriggerStates(t,{hasEnteredOnce:!0})},this.onTriggerLeave=(t,s="Leave")=>{let{once:e}=this.getTriggerData(t),{hasEnteredOnce:i}=this.getTriggerStates(t),{onLeave:o,onLeaveBack:a,toggleClass:n,animation:l}=this.getTriggerData(t),h=s==="Leave",u={callback:h?o:a,leaveProp:h?"hasLeft":"hasLeftBack",eventIndex:h?1:3};u.callback(t,this),n&&this._it.toggleClass.toggle(t,n,u.eventIndex),l&&this._it.animation.animate(t,l,u.eventIndex),this.setTriggerStates(t,{[u.leaveProp]:!0,hasEntered:!1,hasEnteredBack:!1}),e&&i&&this._it.remove(t)},this.toggleActions=t=>{let s=t.getBoundingClientRect();this._it.rootBounds=this.getRootRect(this._it.observer.rootMargin);let e=this._it.rootBounds,{enter:i,leave:o}=this.getTriggerData(t),{hasEnteredFromOneSide:a,hasLeft:n,hasLeftBack:l}=this.getTriggerStates(t),{ref:h,refOpposite:u,length:g}=this.dirProps(),v=!0;switch(!0){case(l&&s[h]+i*s[g]<=e[u]&&s[h]+i*s[g]>e[h]):this.onTriggerEnter(t);break;case(a&&s[h]+o*s[g]<=e[h]):this.onTriggerLeave(t);break;case(n&&s[h]+o*s[g]>=e[h]&&s[h]+o*s[g]<e[u]):this.onTriggerEnter(t,"EnterBack");break;case(a&&s[h]+i*s[g]>=e[u]):this.onTriggerLeave(t,"hasLeftBack");break;default:v=!1;break}return v},this.parseRootMargin=t=>{var s=t||"0px",e=y(s);return e[1]=e[1]||e[0],e[2]=e[2]||e[0],e[3]=e[3]||e[1],e},this.expandRectByRootMargin=(t,s)=>{let e=this.parseRootMargin(s).map((o,a)=>o.unit=="px"?o.value:o.value*(a%2?t.width:t.height)/100),i={top:t.top-e[0],right:t.right+e[1],bottom:t.bottom+e[2],left:t.left-e[3]};return i.width=i.right-i.left,i.height=i.bottom-i.top,i},this.getRootRect=t=>{let s;if(this._it._root&&!c.doc(this._it._root))return s=C(this._it._root),this.expandRectByRootMargin(s,t);let e=c.doc(this._it._root)?this._it._root:document,i=e.documentElement,o=e.body;return s={top:0,left:0,right:i.clientWidth||o.clientWidth,width:i.clientWidth||o.clientWidth,bottom:i.clientHeight||o.clientHeight,height:i.clientHeight||o.clientHeight},this.expandRectByRootMargin(s,t)}}},O=T;var M=[],m=[],V=0,d=class{constructor(t={}){this._userOptions=t,this.triggers=[],this._triggersData=new WeakMap,this._guidesInstance=null,this._utils=new O(this),this.id=V,V++,m.push(this),this.animation=null,this.toggleClass=null,this._setStates(),this._setPlugins(),this._setInstance()}_setPlugins(){d.getRegisteredPlugins().forEach(s=>{switch(s.name){case"Animation":this.animation=new s(this);break;case"ToggleClass":this.toggleClass=new s(this);break}})}_setStates(){this._states={},this._states.oCbFirstInvoke=!0,this._states.runningScrollCbs=0}_rAFCallback=t=>{this.triggers.forEach(s=>{let e=this._utils.getTriggerStates(s,"onScroll");for(let i in e)e[i]&&c.function(e[i])&&e[i](s,t)})};_onScrollHandler=()=>requestAnimationFrame(this._rAFCallback);addScrollListener(t){this._utils.getRoot().addEventListener("scroll",t,!1)}removeScrollListener(t){this._utils.getRoot().removeEventListener("scroll",t,!1)}_createInstance(){this._threshold=this._utils.setThreshold(),this._observerOptions={root:this._root,rootMargin:this._rootMargin,threshold:this._threshold},this.observer=new IntersectionObserver(this._observerCallback,this._observerOptions),this._root=this.observer.root,this.rootBounds=this._utils.getRootRect(this.observer.rootMargin),this._isRootViewport=this._utils.isRootViewport()}_observerCallback=(t,s)=>{let{ref:e,refOpposite:i,length:o}=this._utils.dirProps();for(let a of t){let n=a.target,l=a.boundingClientRect,h=a.isIntersecting,u=a.intersectionRatio;this.rootBounds=a.rootBounds||this._utils.getRootRect(s.rootMargin);let g=this.rootBounds,v=g[o],k=v/l[o],{enter:S,leave:p}=this._utils.getTriggerData(n),{hasEnteredFromOneSide:E,onScroll:{backup:H}}=this._utils.getTriggerStates(n),A=l[o]>=v,F=S>k,$=1-p>k,L=A&&(F||$),x=!!H,W=l[e]+S*l[o]<g[i]&&l[e]+S*l[o]>g[e],j=l[e]+p*l[o]<g[i]&&l[e]+p*l[o]>g[e],U=l[e]+S*l[o]<g[e],Q=l[e]+p*l[o]>g[i],G=l[e]+p*l[o]<g[e]&&u<1-p,N=l[e]<g[e],z=l[i]<g[e];switch(!0){case this._states.oCbFirstInvoke:switch(!0){case(!h&&N&&z):this._utils.onTriggerEnter(n),this._utils.onTriggerLeave(n);break;case h:switch(!0){case(W||j||U&&Q):this._utils.onTriggerEnter(n);break;case G:this._utils.onTriggerEnter(n),this._utils.onTriggerLeave(n);break}L&&this._utils.setTriggerScrollStates(n,"backup",this._utils.toggleActions);break}break;case!h:switch(x&&this._utils.setTriggerScrollStates(n,"backup",null),!0){case(E&&l[i]<g[e]):this._utils.onTriggerLeave(n);break;case(E&&l[e]>g[i]):this._utils.onTriggerLeave(n,"onLeaveBack");break}break;case(h&&!x):this._utils.toggleActions(n),L&&this._utils.setTriggerScrollStates(n,"backup",this._utils.toggleActions);break}}this._states.oCbFirstInvoke=!1};_setInstance(){this._defaultOptions=R,this._options=P(this._defaultOptions,this._userOptions),this.axis=c.string(this._options.axis)?this._options.axis:_("axis parameter must be a string."),this.name=c.string(this._options.name)?this._options.name:_("name parameter must be a string."),this._root=!!this._options.root&&this._utils.customParseQuery(this._options.root,"root")||null,this._positions=this._utils.parsePositions(this._options.enter,this._options.leave),this.customScrollHandler=this._options.onScroll;let{once:t,onEnter:s,onLeave:e,onEnterBack:i,onLeaveBack:o,toggleClass:a,animation:n}=this._options.defaults;return this._triggerParams={enter:this._positions.triggerEnterPosition.value,leave:this._positions.triggerLeavePosition.value,once:t,onEnter:s,onLeave:e,onEnterBack:i,onLeaveBack:o,toggleClass:a,animation:n},this._rootMargin=this._utils.setRootMargin(),this._createInstance(),this.customScrollHandler&&this.addScrollListener(this.customScrollHandler),this}add(t={},s={}){let e=this._utils.customParseQuery(t);"enter"in s&&(s.enter=this._utils.setPositionData(s.enter).value),"leave"in s&&(s.leave=this._utils.setPositionData(s.leave).value);let i={...P(this._triggerParams,s),states:{...D}};i.toggleClass&&(i.toggleClass=this.toggleClass.parse(i.toggleClass)),i.animation&&(i.animation=this.animation.parse(i.animation)),this.triggers=[...new Set([...this.triggers,...e])];let o=!1;return[s.enter,s.leave].forEach(a=>!this._threshold.some(n=>a===n)&&(o=!0)),o?(this._disconnect(),e.forEach(a=>this._utils.setTriggerData(a,i)),this._createInstance(),this.triggers.forEach(a=>this.observer.observe(a))):e.forEach(a=>{this._utils.setTriggerData(a,i),this.observer.observe(a)}),this._guidesInstance&&this._guidesInstance.refresh(),this}remove(t={}){let s=this._utils.customParseQuery(t);s.forEach(i=>{this._utils.deleteTriggerData(i),this.observer.unobserve(i)});let e=this.triggers.filter(i=>!s.some(a=>i===a));return this.triggers=e,this._guidesInstance&&this._guidesInstance.refresh(),this}_disconnect(){this.observer&&this.observer.disconnect(),this.observer=null}kill(){this._disconnect(),this.removeScrollListener(this.customScrollHandler),this.triggers=[],this.removeGuides(),this.animation&&this.animation.kill(),this.toggleClasss&&this.toggleClasss.kill();let t=m.indexOf(this);~t&&m.splice(t,1)}addGuides(t){return c.inObject(t,"_registerIntersectionTrigger")||_("Invalid Guides Instance."),t._registerIntersectionTrigger(this),t.refresh(),this._guidesInstance=t,this}removeGuides(){return this._guidesInstance&&this._guidesInstance.kill(),this._guidesInstance=null,this}update(){this._guidesInstance&&this._guidesInstance.refresh()}};d.getInstances=()=>m;d.getInstanceById=r=>m.find(t=>t.id===r);d.update=()=>m.forEach(r=>r.update());d.registerPlugins=(r=[])=>M.push(...r);d.getRegisteredPlugins=()=>M;
