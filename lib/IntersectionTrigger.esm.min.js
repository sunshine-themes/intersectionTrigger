/*
* IntersectionTrigger v1.0.0
* https://sunshine-themes.com/intersectionTrigger
*
* @license Copyright 2022, Sunshine. All rights reserved.
* Subject to the terms at https://sunshine-themes.com/intersectionTrigger/standard-licensew.
* @author: Sherif magdy, sherifmagdy@sunshine-themes.com
*/
                  
var _=()=>{},S={defaults:{once:!1,onEnter:_,onLeave:_,onEnterBack:_,onLeaveBack:_,toggleClass:null},enter:"0% 100%",leave:"100% 0%",axis:"y",name:"",root:null,onScroll:_},T={hasEntered:!1,hasEnteredBack:!1,hasLeft:!0,hasLeftBack:!0,hasEnteredOnce:!1,onScroll:null};var L="add remove add remove";var f=class{constructor(t){return this._it=t,this.setHelpers(),this}setHelpers(){this.is={function:t=>typeof t=="function",string:t=>typeof t=="string",boolean:t=>typeof t=="boolean",object:t=>t&&typeof t=="object"&&!(t instanceof Array),inObject:(t,e)=>this.is.object(t)&&e in t,percent:t=>t&&t.includes("%"),pixel:t=>t&&t.includes("px"),array:t=>t instanceof Array,element:t=>t instanceof HTMLElement||t instanceof Element,rootViewport:t=>!t,doc:t=>t&&t.nodeType===9,scrollable:(t,e=null)=>e?e==="y"?t.scrollHeight>t.clientHeight:t.scrollWidth>t.clientWidth:t.scrollHeight>t.clientHeight||t.scrollWidth>t.clientWidth,virtical:()=>this._it.axis==="y",horizontal:()=>this._it.axis==="x",anime:t=>this.is.object(t)&&t.hasOwnProperty("animatables")&&!t.hasOwnProperty("add"),tl:t=>this.is.object(t)&&t.hasOwnProperty("add")&&this.is.function(t.add)},this.getBoundsProp=(t,e)=>t&&t.getBoundingClientRect()[e],this.getRoot=()=>this._it._root??window,this.getScrollValue=(t,e)=>e==="y"?t.scrollHeight:t.scrollWidth,this.dirProps=()=>this.is.virtical()?{ref:"top",length:"height",refOpposite:"bottom",innerLength:innerHeight}:{ref:"left",length:"width",refOpposite:"right",innerLength:innerWidth},this.roundFloat=(t,e)=>{this.is.string(t)&&(t=parseFloat(t));let s=Math.pow(10,e||0);return Math.round(t*s)/s},this.getParents=t=>{let e=[];for(t=t.parentNode;t&&t!==document&&t!==document.documentElement;t=t.parentNode)e.push(t);return e},this.mergeOptions=(t,e)=>{let s=t,i=e;return Object.entries(s).forEach(([r,o])=>{this.is.object(o)?this.mergeOptions(o,i[r]=i[r]||{}):r in i||(i[r]=o)}),i},this.throwError=t=>{throw new Error(t)},this.boundsMinusScrollbar=t=>{let e=t.getBoundingClientRect(),{top:s,bottom:i,right:r,left:o,height:n,width:a,x:h,y:c}=e;return{top:s,left:o,height:n,width:a,x:h,y:c,right:r-(r-o-t.clientWidth),bottom:i-(i-s-t.clientHeight)}}}},w=f;var v=class{constructor(t){return this._it=t,this._helpers=this._it._helpers,this.setUtils(),this}setUtils(){this.setRootMargin=()=>{let t=this._helpers.getScrollValue(this._helpers.is.rootViewport(this._it._root)?document.body:this._it._root,this._helpers.is.virtical()?"x":"y");return this._helpers.is.virtical()?`${this._it._positions.rootEndPosition.strValue} ${t}px ${this._it._positions.rootStartPosition.strValue} ${t}px`:`${t}px ${this._it._positions.rootStartPosition.strValue} ${t}px ${this._it._positions.rootEndPosition.strValue}`},this.setThreshold=()=>{let t=[0,this._it._triggerParams.enter,this._it._triggerParams.leave,this._helpers.roundFloat(1-this._it._triggerParams.leave,2),1];return this._it.triggers.forEach(e=>{let{enter:s,leave:i}=this.getTriggerData(e);t.push(s,i,this._helpers.roundFloat(1-i,2))}),[...new Set(t)]},this.parseQuery=(t,e)=>{switch(!0){case this._helpers.is.string(t):return[...document.querySelectorAll(t)];case this._helpers.is.array(t):return t;case this._helpers.is.element(t):return[t];default:this._helpers.throwError(`${e} parameter must be a valid selector, an element or array of elements`)}},this.customParseQuery=(t,e="trigger")=>{let s=e==="trigger",i=s?[]:{};return s?this.parseQuery(t,"trigger"):(i=this._helpers.is.string(t)?document.querySelector(t):this._helpers.is.element(t)?t:this._helpers.throwError("root parameter must be a valid selector or an element"),i)},this.validatePosition=(t,e)=>(this._helpers.is.function(e)&&(e=e(this)),this._helpers.is.string(e)||this._helpers.throwError(`${t} parameter must be a string.`),e),this.setPositionData=(t,e=!0,s=!0)=>{t=this.validatePosition(s?"enter":"leave",t);let i=t.trim(),r=this._helpers.is.percent(i),o=this._helpers.is.pixel(i),n={};if(i=r?i.replace("%",""):o?i.replace("px",""):i,i=this._helpers.roundFloat(i),n.type=r?"percent":"pixel",r&&e)return n.value=i/100,n.strValue=`${i}%`,n;let{length:a,innerLength:h}=this._helpers.dirProps(),c=this._it._root?this._helpers.getBoundsProp(this._it._root,a):h;switch(!0){case(r&&s):n.value=this._helpers.roundFloat(i/100-1,2),n.strValue=`${n.value*100}%`;break;case(r&&!s):n.value=-i/100,n.strValue=`${n.value*100}%`;break;case(o&&s):n.value=this._helpers.roundFloat(i-c,2),n.strValue=`${n.value}px`;break;case(o&&!s):n.value=-i,n.strValue=`${-i}px`;break}return n.guide=t,n},this.parsePositions=(t="",e="")=>{t=this.validatePosition("enter",t),e=this.validatePosition("leave",e);let s={},i={},r={},o={},n=t.trim().split(/\s+/g,2),a=e.trim().split(/\s+/g,2);return[...n,...a].forEach((l,g)=>{switch(g){case 0:s=this.setPositionData(l);break;case 1:r=this.setPositionData(l,!1);break;case 2:i=this.setPositionData(l);break;case 3:o=this.setPositionData(l,!1,!1);break}}),{triggerLeavePosition:i,triggerEnterPosition:s,rootEndPosition:o,rootStartPosition:r}},this.deleteTriggerData=t=>{this._it._triggersData.delete(t)},this.hasTriggerData=(t,e=null)=>{let s=this._it._triggersData.has(t);return e?s&&e in this.getTriggerData(t):s},this.getTriggerData=(t,e=null)=>e?this.hasTriggerData(t,e)?this._it._triggersData.get(t)[e]:{}:this.hasTriggerData(t)&&this._it._triggersData.get(t)||{},this.setTriggerData=(t,e,s=null)=>{if(s){let i=this.getTriggerData(t);this._helpers.is.object(i)&&this._it._triggersData.set(t,{...i,...s});return}this._it._triggersData.set(t,e)},this.getTriggerStates=t=>{let e=this.getTriggerData(t,"states"),s=e.hasEntered||e.hasEnteredBack;return{...e,hasEnteredFromOneSide:s}},this.setTriggerStates=(t,e={})=>{let s=this.getTriggerData(t),i=s&&{...s.states,...e};this.setTriggerData(t,null,{states:i})},this.onTriggerEnter=(t,e="Enter")=>{let{hasEnteredOnce:s}=this.getTriggerStates(t),{onEnter:i,onEnterBack:r,classNamesData:o}=this.getTriggerData(t),n=e==="Enter",a={callback:n?i:r,enterProp:n?"hasEntered":"hasEnteredBack",leaveProp:n?"hasLeftBack":"hasLeft",eventIndex:n?0:2};a.callback(t,this),this.toggleClass(t,o,a.eventIndex);let h=s?{[a.enterProp]:!0,[a.leaveProp]:!1}:{[a.enterProp]:!0,hasLeft:!1,hasLeftBack:!1};this.setTriggerStates(t,h),s||this.setTriggerStates(t,{hasEnteredOnce:!0})},this.onTriggerLeave=(t,e="Leave")=>{let{once:s}=this.getTriggerData(t),{hasEnteredOnce:i}=this.getTriggerStates(t),{onLeave:r,onLeaveBack:o,classNamesData:n}=this.getTriggerData(t),a=e==="Leave",h={callback:a?r:o,leaveProp:a?"hasLeft":"hasLeftBack",eventIndex:a?1:3};h.callback(t,this),this.toggleClass(t,n,h.eventIndex),this.setTriggerStates(t,{[h.leaveProp]:!0,hasEntered:!1,hasEnteredBack:!1}),s&&i&&this._it.remove(t)},this.toggleClass=(t,e,s)=>{for(let{targets:i,toggleActions:r,classNames:o}of e)r[s]!=="none"&&o.forEach(n=>i.forEach(a=>a==="trigger"?t.classList[r[s]](n):a.classList[r[s]](n)))},this.parseClassNames=t=>{let e=[],s=i=>i.split(/\s+/);return this._helpers.is.string(t)?(e.push({targets:["trigger"],classNames:s(t),toggleActions:s(L)}),e):(this._helpers.is.array(t)&&(e=t.map(i=>({targets:this.parseQuery(i.targets,"targets"),classNames:s(i.classNames),toggleActions:s(i.toggleActions)}))),e)},this.toggleActions=t=>{let e=t.getBoundingClientRect();this._it.rootBounds=this.getRootRect(this._it.observer.rootMargin);let s=this._it.rootBounds,{enter:i,leave:r}=this.getTriggerData(t),{hasEnteredFromOneSide:o,hasLeft:n,hasLeftBack:a}=this.getTriggerStates(t),{ref:h,refOpposite:c,length:l}=this._helpers.dirProps(),g=!0;switch(!0){case(a&&e[h]+i*e[l]<=s[c]&&e[h]+i*e[l]>s[h]):this.onTriggerEnter(t);break;case(o&&e[h]+r*e[l]<=s[h]):this.onTriggerLeave(t);break;case(n&&e[h]+r*e[l]>=s[h]&&e[h]+r*e[l]<s[c]):this.onTriggerEnter(t,"EnterBack");break;case(o&&e[h]+i*e[l]>=s[c]):this.onTriggerLeave(t,"hasLeftBack");break;default:g=!1;break}return g},this.validateOptions=t=>{for(let e in t){let s=t[e],i=(r,o)=>{switch(r){case"once":!this._helpers.is.boolean(o)&&this._helpers.throwError("once parameter must be a boolean.");break;case"axis":case"name":!this._helpers.is.string(o)&&this._helpers.throwError("axis and name parameters must be strings.");break;case"animation":!this._helpers.is.anime(o)&&!this._helpers.is.tl(o)&&this._helpers.throwError("animation parameter must be an anime instance or timeline.");break;case"toggleClass":!this._helpers.is.string(o)&&!this._helpers.is.array(o)&&this._helpers.throwError("toggleClass parameter must be a string or an Array.");break;case"onEnter":case"onEnterBack":case"onLeave":case"onLeaveBack":case"onScroll":!this._helpers.is.function(o)&&this._helpers.throwError("onEnter, onLeave, onEnterBack, onLeaveBack and onScroll parameters must be functions.");break}};if(!this._helpers.is.object(s)){i(e,s);continue}for(let r in s){let o=s[r];i(r,o)}}},this.parseString=t=>t.split(/\s+/).map(s=>{let i=/^(-?\d*\.?\d+)(px|%)$/.exec(s);return{value:parseFloat(i[1]),unit:i[2]}}),this.parseRootMargin=t=>{var e=t||"0px",s=this.parseString(e);return s[1]=s[1]||s[0],s[2]=s[2]||s[0],s[3]=s[3]||s[1],s},this.expandRectByRootMargin=(t,e)=>{let s=this.parseRootMargin(e).map((r,o)=>r.unit=="px"?r.value:r.value*(o%2?t.width:t.height)/100),i={top:t.top-s[0],right:t.right+s[1],bottom:t.bottom+s[2],left:t.left-s[3]};return i.width=i.right-i.left,i.height=i.bottom-i.top,i},this.getRootRect=t=>{let e;if(this._it._root&&!this._helpers.is.doc(this._it._root))return e=this._helpers.boundsMinusScrollbar(this._it._root),this.expandRectByRootMargin(e,t);let s=this._helpers.is.doc(this._it._root)?this._it._root:document,i=s.documentElement,r=s.body;return e={top:0,left:0,right:i.clientWidth||r.clientWidth,width:i.clientWidth||r.clientWidth,bottom:i.clientHeight||r.clientHeight,height:i.clientHeight||r.clientHeight},this.expandRectByRootMargin(e,t)}}},B=v;var d=[],D=0,x=class{constructor(t={}){this._userOptions=t,this.triggers=[],this._triggersData=new WeakMap,this._guidesInstance=null,this._helpers=new w(this),this._utils=new B(this),this.id=D,D++,d.push(this),this._setStates(),this._setInstance()}_setStates(){this._states={},this._states.oCbFirstInvoke=!0}_addScrollListener(){let t=this._helpers.getRoot();!!this._onScrollHandler&&t.removeEventListener("scroll",this._onScrollHandler,!1),this._onScrollHandler=e=>{requestAnimationFrame(()=>{this.triggers.forEach(i=>{let r=this._utils.getTriggerStates(i)?.onScroll;r&&r(i)}),this.onScroll(e,this)})},t.addEventListener("scroll",this._onScrollHandler,!1)}_createInstance(){this._threshold=this._utils.setThreshold(),this._observerOptions={root:this._root,rootMargin:this._rootMargin,threshold:this._threshold},this.observer=new IntersectionObserver(this._observerCallback,this._observerOptions),this._root=this.observer.root,this.rootBounds=this._utils.getRootRect(this.observer.rootMargin),this._isRootViewport=this._helpers.is.rootViewport(this._root),this._addScrollListener()}_observerCallback=(t,e)=>{let{ref:s,refOpposite:i,length:r}=this._helpers.dirProps();for(let o of t){let n=o.target,a=o.boundingClientRect,h=o.isIntersecting,c=o.intersectionRatio;this.rootBounds=o.rootBounds||this._utils.getRootRect(e.rootMargin);let l=this.rootBounds,g=l[r],m=g/a[r],{enter:p,leave:u,onEnter:V,onLeave:W,onLeaveBack:j}=this._utils.getTriggerData(n),{hasEnteredFromOneSide:E,onScroll:O}=this._utils.getTriggerStates(n),R=a[r]>=g,I=p>m,y=1-u>m,k=R&&(I||y),P=!!O,C=a[s]+p*a[r]<l[i]&&a[s]+p*a[r]>l[s],F=a[s]+u*a[r]<l[i]&&a[s]+u*a[r]>l[s],H=a[s]+p*a[r]<l[s],M=a[s]+u*a[r]>l[i],A=a[s]+u*a[r]<l[s]&&c<1-u,$=a[s]<l[s],N=a[i]<l[s];switch(!0){case this._states.oCbFirstInvoke:switch(!0){case(!h&&$&&N):this._utils.onTriggerEnter(n),this._utils.onTriggerLeave(n);break;case h:switch(!0){case(C||F||H&&M):this._utils.onTriggerEnter(n);break;case A:this._utils.onTriggerEnter(n),this._utils.onTriggerLeave(n);break}k&&this._utils.setTriggerStates(n,{onScroll:this._utils.toggleActions});break}break;case!h:switch(P&&this._utils.setTriggerStates(n,{onScroll:null}),!0){case(E&&a[i]<l[s]):this._utils.onTriggerLeave(n);break;case(E&&a[s]>l[i]):this._utils.onTriggerLeave(n,"onLeaveBack");break}break;case(h&&!P):this._utils.toggleActions(n),k&&this._utils.setTriggerStates(n,{onScroll:this._utils.toggleActions});break}}this._states.oCbFirstInvoke=!1};_setInstance(){return this._defaultOptions=S,this._utils.validateOptions(this._userOptions),this._options=this._helpers.mergeOptions(this._defaultOptions,this._userOptions),this.axis=this._helpers.is.string(this._options.axis)?this._options.axis:this._helpers.throwError("axis parameter must be a string."),this.name=this._helpers.is.string(this._options.name)?this._options.name:this._helpers.throwError("name parameter must be a string."),this._root=!!this._options.root&&this._utils.customParseQuery(this._options.root,"root")||null,this._positions=this._utils.parsePositions(this._options.enter,this._options.leave),this.onScroll=this._options.onScroll,this._triggerParams={enter:this._positions.triggerEnterPosition.value,leave:this._positions.triggerLeavePosition.value,once:this._options.defaults.once,onEnter:this._options.defaults.onEnter,onLeave:this._options.defaults.onLeave,onEnterBack:this._options.defaults.onEnterBack,onLeaveBack:this._options.defaults.onLeaveBack,toggleClass:this._options.defaults.toggleClass},this._rootMargin=this._utils.setRootMargin(),this._createInstance(),this}add(t={},e={}){let s=this._utils.customParseQuery(t);this._utils.validateOptions(e),"enter"in e&&(e.enter=this._utils.setPositionData(e.enter).value),"leave"in e&&(e.leave=this._utils.setPositionData(e.leave).value);let i={...this._triggerParams,...e,states:{...T}};i.classNamesData=this._utils.parseClassNames(i.toggleClass),this.triggers=[...this.triggers,...s],this.triggers=[...new Set(this.triggers)];let r=!1;return[e.enter,e.leave].forEach(o=>!this._threshold.some(n=>o===n)&&(r=!0)),r?(this._disconnect(),s.forEach(o=>this._utils.setTriggerData(o,i)),this._createInstance(),this.triggers.forEach(o=>this.observer.observe(o))):s.forEach(o=>{this._utils.setTriggerData(o,i),this.observer.observe(o)}),this._guidesInstance&&this._guidesInstance.refresh(),this}remove(t={}){let e=this._utils.customParseQuery(t);e.forEach(i=>{this._utils.deleteTriggerData(i),this.observer.unobserve(i)});let s=this.triggers.filter(i=>!e.some(o=>i===o));return this.triggers=s,this._guidesInstance&&this._guidesInstance.refresh(),this}_disconnect(){this.observer&&this.observer.disconnect(),this.observer=null}kill(){this._disconnect(),removeEventListener("scroll",this._onScrollHandler,!1),this.triggers=[],this.removeGuides();let t=d.indexOf(this);~t&&d.splice(t,1)}addGuides(t){return this._helpers.is.inObject(t,"_registerIntersectionTrigger")||this._helpers.throwError("Invalid Guides Instance."),t._registerIntersectionTrigger(this),t.refresh(),this._guidesInstance=t,this}removeGuides(){return this._guidesInstance&&this._guidesInstance.kill(),this._guidesInstance=null,this}};x.instances=d;export{x as default};
