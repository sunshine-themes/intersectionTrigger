/*
* IntersectionTrigger v1.0.0
* https://sunshine-themes.com/intersectionTrigger
*
* @license Copyright 2022, Sunshine. All rights reserved.
* Subject to the terms at https://sunshine-themes.com/intersectionTrigger/standard-licensew.
* @author: Sherif magdy, sherifmagdy@sunshine-themes.com
*/
                  
var x=()=>{},ot=["add","remove","add","remove"],at=["play","finish","reverse","finish"],J={to:null,after:1,speed:600,maxDistance:500},K={defaults:{once:!1,onEnter:x,onLeave:x,onEnterBack:x,onLeaveBack:x,toggleClass:null,animation:null},enter:"0% 100%",leave:"100% 0%",axis:"y",name:"",root:null,onScroll:x},X={hasEntered:!1,hasEnteredBack:!1,hasLeft:!0,hasLeftBack:!0,hasEnteredOnce:!1,onScroll:{backup:null,animate:null},ids:{snapTimeOutId:0}};var G={targets:null,toggleActions:ot,classNames:null},j={instance:null,toggleActions:at,control:!1,snap:!1};var c={function:r=>typeof r=="function",string:r=>typeof r=="string",boolean:r=>typeof r=="boolean",object:r=>r&&typeof r=="object"&&!(r instanceof Array),inObject:(r,t)=>c.object(r)&&t in r,num:r=>typeof r=="number",percent:r=>r&&r.includes("%"),pixel:r=>r&&r.includes("px"),array:r=>r instanceof Array,element:r=>r instanceof HTMLElement||r instanceof Element,doc:r=>r&&r.nodeType===9,scrollable:(r,t=null)=>t?t==="y"?r.scrollHeight>r.clientHeight:r.scrollWidth>r.clientWidth:r.scrollHeight>r.clientHeight||r.scrollWidth>r.clientWidth,anime:r=>c.object(r)&&r.hasOwnProperty("animatables")&&!r.hasOwnProperty("add"),tl:r=>c.object(r)&&r.hasOwnProperty("add")&&c.function(r.add),animeInstance:r=>c.anime(r)||c.tl(r)},Y=(r,t,i)=>Math.min(Math.max(r,t),i),y=r=>r.split(/\s+/),Z=(r,t)=>r&&r.getBoundingClientRect()[t],q=(r,t)=>t==="y"?r.scrollHeight:r.scrollWidth,S=(r,t)=>{c.string(r)&&(r=parseFloat(r));let i=Math.pow(10,t||0);return Math.round(r*i)/i};var _=(r,t)=>{let i=r,s=t;return Object.entries(i).forEach(([e,n])=>{c.object(n)?_(n,s[e]=s[e]||{}):e in s||(s[e]=n)}),s},f=r=>{throw new Error(r)},tt=r=>{let t=r.getBoundingClientRect(),{top:i,bottom:s,right:e,left:n,height:a,width:o,x:l,y:h}=t;return{top:i,left:n,height:a,width:o,x:l,y:h,right:e-(e-n-r.clientWidth),bottom:s-(s-i-r.clientHeight)}};var z=class{constructor(t){return this._it=t,this.setUtils(),this}setUtils(){this.isVirtical=()=>this._it.axis==="y",this.isRootViewport=()=>!this._it._root,this.getRoot=()=>this._it._root??window,this.dirProps=()=>this.isVirtical()?{ref:"top",length:"height",refOpposite:"bottom",innerLength:innerHeight}:{ref:"left",length:"width",refOpposite:"right",innerLength:innerWidth},this.setRootMargin=()=>{let t=q(this.isRootViewport()?document.body:this._it._root,this.isVirtical()?"x":"y");return this.isVirtical()?`${this._it._positions.rootLeavePosition.strValue} ${t}px ${this._it._positions.rootEnterPosition.strValue} ${t}px`:`${t}px ${this._it._positions.rootEnterPosition.strValue} ${t}px ${this._it._positions.rootLeavePosition.strValue}`},this.setThreshold=()=>{let t=[0,this._it._triggerParams.enter,this._it._triggerParams.leave,S(1-this._it._triggerParams.leave,2),1];return this._it.triggers.forEach(i=>{let{enter:s,leave:e}=this.getTriggerData(i);t.push(s,e,S(1-e,2))}),[...new Set(t)]},this.parseQuery=(t,i)=>{switch(!0){case c.string(t):return[...document.querySelectorAll(t)];case c.array(t):return t;case c.element(t):return[t];default:f(`${i} parameter must be a valid selector, an element or array of elements`)}},this.customParseQuery=(t,i="trigger")=>{let s=i==="trigger",e=s?[]:{};return s?this.parseQuery(t,"trigger"):(e=c.string(t)?document.querySelector(t):c.element(t)?t:f("root parameter must be a valid selector or an element"),e)},this.validatePosition=(t,i)=>(c.function(i)&&(i=i(this._it)),c.string(i)||f(`${t} parameter must be a string.`),i),this.setPositionData=(t,i=!0,s=!0)=>{t=this.validatePosition(s?"enter":"leave",t);let e=t.trim(),n=c.percent(e),a=c.pixel(e),o={};if(e=n?e.replace("%",""):a?e.replace("px",""):e,e=S(e),o.type=n?"percent":"pixel",n&&i)return o.value=e/100,o.strValue=`${e}%`,o;let{length:l,innerLength:h}=this.dirProps(),g=this._it._root?Z(this._it._root,l):h;switch(!0){case(n&&s):o.value=S(e/100-1,2),o.strValue=`${o.value*100}%`;break;case(n&&!s):o.value=-e/100,o.strValue=`${o.value*100}%`;break;case(a&&s):o.value=S(e-g,2),o.strValue=`${o.value}px`;break;case(a&&!s):o.value=-e,o.strValue=`${-e}px`;break}return o.guide=t,o},this.parsePositions=(t="",i="")=>{t=this.validatePosition("enter",t),i=this.validatePosition("leave",i);let s=t.trim().split(/\s+/g,2),e=i.trim().split(/\s+/g,2),n=[...s,...e];return{triggerEnterPosition:this.setPositionData(n[0]),rootEnterPosition:this.setPositionData(n[1],!1),triggerLeavePosition:this.setPositionData(n[2]),rootLeavePosition:this.setPositionData(n[3],!1,!1)}},this.deleteTriggerData=t=>{this._it._triggersData.delete(t)},this.hasTriggerData=(t,i=null)=>{let s=this._it._triggersData.has(t);return i?s&&i in this.getTriggerData(t):s},this.getTriggerData=(t,i=null)=>i?this.hasTriggerData(t,i)?this._it._triggersData.get(t)[i]:{}:this.hasTriggerData(t)&&this._it._triggersData.get(t)||{},this.setTriggerData=(t,i,s=null)=>{if(s){let e=this.getTriggerData(t);c.object(e)&&this._it._triggersData.set(t,{...e,...s});return}this._it._triggersData.set(t,i)},this.getTriggerStates=(t,i=null)=>{let s=this.getTriggerData(t,"states"),e=s.hasEntered||s.hasEnteredBack;return i?s[i]:{...s,hasEnteredFromOneSide:e}},this.setTriggerStates=(t,i={})=>{let s=this.getTriggerData(t),e=s&&{...s.states,...i};this.setTriggerData(t,null,{states:e})},this.setTriggerScrollStates=(t,i,s=null)=>{let e=this.getTriggerStates(t,"onScroll");if(e[i]=s,this.setTriggerStates(t,{onscroll:{...e}}),s){this._it._states.runningScrollCbs===0&&this._it.addScrollListener(this._it._onScrollHandler),this._it._states.runningScrollCbs++;return}0<this._it._states.runningScrollCbs&&this._it._states.runningScrollCbs--,this._it._states.runningScrollCbs===0&&this._it.removeScrollListener(this._it._onScrollHandler)},this.onTriggerEnter=(t,i="Enter")=>{let{hasEnteredOnce:s}=this.getTriggerStates(t),{onEnter:e,onEnterBack:n,toggleClass:a,animation:o}=this.getTriggerData(t),l=i==="Enter",h={callback:l?e:n,enterProp:l?"hasEntered":"hasEnteredBack",leaveProp:l?"hasLeftBack":"hasLeft",eventIndex:l?0:2};h.callback(t,this),a&&this.toggleClass(t,a,h.eventIndex),o&&this.animate(t,o,h.eventIndex);let g=s?{[h.enterProp]:!0,[h.leaveProp]:!1}:{[h.enterProp]:!0,hasLeft:!1,hasLeftBack:!1};this.setTriggerStates(t,g),s||this.setTriggerStates(t,{hasEnteredOnce:!0})},this.onTriggerLeave=(t,i="Leave")=>{let{once:s}=this.getTriggerData(t),{hasEnteredOnce:e}=this.getTriggerStates(t),{onLeave:n,onLeaveBack:a,toggleClass:o,animation:l}=this.getTriggerData(t),h=i==="Leave",g={callback:h?n:a,leaveProp:h?"hasLeft":"hasLeftBack",eventIndex:h?1:3};g.callback(t,this),o&&this.toggleClass(t,o,g.eventIndex),l&&this.animate(t,l,g.eventIndex),this.setTriggerStates(t,{[g.leaveProp]:!0,hasEntered:!1,hasEnteredBack:!1}),s&&e&&this._it.remove(t)},this.animate=(t,i,s)=>{let{instance:e,toggleActions:n,control:a,snap:o}=i;if(!e)return;if(a){let{animate:h}=this.getTriggerStates(t,"onScroll"),g=this.getTriggerStates(t,"ids"),{enter:u,leave:d}=this.getTriggerData(t),{ref:m,refOpposite:b,length:p}=this.dirProps(),w=this.isVirtical(),E=t.getBoundingClientRect(),W=E[p]-(u*E[p]+(1-d)*E[p]),O=this.getRoot(),C=e.duration,L=v=>{let A=v.getBoundingClientRect(),M=this.getTriggerStates(v,"ids");this._it.rootBounds=this.getRootRect(this._it.observer.rootMargin);let V=this._it.rootBounds,H=W+V[p],T=0,F=V[b]-(A[m]+u*A[p]);if(F>0&&(T=C*F/H,c.num(a)?setTimeout(()=>e.seek(T),a*1e3):e.seek(T)),o){let I=o.speed*17/1e3,N=0,Q=(B,D=!1)=>{let R=D?-1:1;if(w?O.scrollBy({top:I*R,behavior:"instant"}):O.scrollBy({left:I*R,behavior:"instant"}),N+=I,N>=B){N=0;return}requestAnimationFrame(()=>Q(B,D))};clearTimeout(M.snapTimeOutId);let rt=setTimeout(()=>{let B=o.to.map(U=>T-U),D=B.map(U=>Math.abs(U)),R=Math.min(...D),nt=B[D.indexOf(R)],$=H*R/C;if(!($>=o.maxDistance||$<10)){if(nt<0){Q($);return}Q($,!0)}},o.after*1e3);this.setTriggerStates(v,{ids:{...M,snapTimeOutId:rt}})}};switch(s){case 0:case 2:if(this._it._states.oCbFirstInvoke&&L(t),h)break;this.setTriggerScrollStates(t,"animate",L);break;case 1:case 3:clearTimeout(g.snapTimeOutId),this.setTriggerScrollStates(t,"animate",null);break}return}let l=n[s];if(l!=="none")switch(l){case"play":e.reversed&&e.reverse(),1>e.progress&&e[l]();break;case"restart":case"reset":e.reversed&&e.reverse(),e[l]();break;case"pause":break;case"finish":e.pause(),e.seek(e.reversed?0:e.duration);break;case"reverse":if(e.reversed)break;e[l](),e.paused&&e.play();break;case"kill":c.inObject(e,"kill")&&e.kill(),this.setTriggerData(t,null,{animation:{...j}});break}},this.parseAnimation=t=>{let i={};switch(!0){case c.animeInstance(t):i=_(j,{instance:t});break;case c.object(t):{let s=_(j,t),{instance:e,toggleActions:n,snap:a}=s;c.animeInstance(e)||f("Invalid anime instance");let o=g=>{let u=[],d=g;for(;d<1;)u.push(Y(d,0,1)),d=d+g;return u.map(m=>Math.round(m*e.duration))},l=g=>{if(c.num(g))return o(g);if(c.string(g))return[];if(c.array(g))return g},h={};switch(!0){case(c.boolean(a)&&a):h.to=[];break;case c.array(a):h.to=a;break;case c.num(a):h.to=o(a);break;case c.object(a):h=a,h.to=l(h.to);break}s.snap=_(J,h),c.string(n)&&(s.toggleActions=y(n)),i=s}break}return c.inObject(i,"instance")&&i.instance.reset(),i},this.toggleClass=(t,i,s)=>{for(let{targets:e,toggleActions:n,classNames:a}of i)n[s]!=="none"&&a.forEach(o=>e.forEach(l=>l==="trigger"?t.classList[n[s]](o):l.classList[n[s]](o)))},this.parseToggleClass=t=>{let i=[];if(c.string(t)){let s=_(G,{targets:["trigger"],classNames:y(t)});return i.push([s]),i}return c.array(t)&&(i=t.map(s=>{let e=_(G,s),{targets:n,classNames:a,toggleActions:o}=e;return n&&(e.targets=this.parseQuery(n,"targets")),a&&(e.classNames=y(a)),c.string(o)&&(e.toggleActions=y(o)),e})),i},this.toggleActions=t=>{let i=t.getBoundingClientRect();this._it.rootBounds=this.getRootRect(this._it.observer.rootMargin);let s=this._it.rootBounds,{enter:e,leave:n}=this.getTriggerData(t),{hasEnteredFromOneSide:a,hasLeft:o,hasLeftBack:l}=this.getTriggerStates(t),{ref:h,refOpposite:g,length:u}=this.dirProps(),d=!0;switch(!0){case(l&&i[h]+e*i[u]<=s[g]&&i[h]+e*i[u]>s[h]):this.onTriggerEnter(t);break;case(a&&i[h]+n*i[u]<=s[h]):this.onTriggerLeave(t);break;case(o&&i[h]+n*i[u]>=s[h]&&i[h]+n*i[u]<s[g]):this.onTriggerEnter(t,"EnterBack");break;case(a&&i[h]+e*i[u]>=s[g]):this.onTriggerLeave(t,"hasLeftBack");break;default:d=!1;break}return d},this.parseString=t=>t.split(/\s+/).map(s=>{let e=/^(-?\d*\.?\d+)(px|%)$/.exec(s);return{value:parseFloat(e[1]),unit:e[2]}}),this.parseRootMargin=t=>{var i=t||"0px",s=this.parseString(i);return s[1]=s[1]||s[0],s[2]=s[2]||s[0],s[3]=s[3]||s[1],s},this.expandRectByRootMargin=(t,i)=>{let s=this.parseRootMargin(i).map((n,a)=>n.unit=="px"?n.value:n.value*(a%2?t.width:t.height)/100),e={top:t.top-s[0],right:t.right+s[1],bottom:t.bottom+s[2],left:t.left-s[3]};return e.width=e.right-e.left,e.height=e.bottom-e.top,e},this.getRootRect=t=>{let i;if(this._it._root&&!c.doc(this._it._root))return i=tt(this._it._root),this.expandRectByRootMargin(i,t);let s=c.doc(this._it._root)?this._it._root:document,e=s.documentElement,n=s.body;return i={top:0,left:0,right:e.clientWidth||n.clientWidth,width:e.clientWidth||n.clientWidth,bottom:e.clientHeight||n.clientHeight,height:e.clientHeight||n.clientHeight},this.expandRectByRootMargin(i,t)}}},et=z;var st=[],k=[],it=0,P=class{constructor(t={}){this._userOptions=t,this.triggers=[],this._triggersData=new WeakMap,this._guidesInstance=null,this._utils=new et(this),this.id=it,it++,k.push(this),this._setStates(),this._setInstance()}_setStates(){this._states={},this._states.oCbFirstInvoke=!0,this._states.runningScrollCbs=0}_rAFCallback=t=>{this.triggers.forEach(i=>{let s=this._utils.getTriggerStates(i,"onScroll");for(let e in s)s[e]&&c.function(s[e])&&s[e](i,t)})};_onScrollHandler=()=>requestAnimationFrame(this._rAFCallback);addScrollListener(t){this._utils.getRoot().addEventListener("scroll",t,!1)}removeScrollListener(t){this._utils.getRoot().removeEventListener("scroll",t,!1)}_createInstance(){this._threshold=this._utils.setThreshold(),this._observerOptions={root:this._root,rootMargin:this._rootMargin,threshold:this._threshold},this.observer=new IntersectionObserver(this._observerCallback,this._observerOptions),this._root=this.observer.root,this.rootBounds=this._utils.getRootRect(this.observer.rootMargin),this._isRootViewport=this._utils.isRootViewport()}_observerCallback=(t,i)=>{let{ref:s,refOpposite:e,length:n}=this._utils.dirProps();for(let a of t){let o=a.target,l=a.boundingClientRect,h=a.isIntersecting,g=a.intersectionRatio;this.rootBounds=a.rootBounds||this._utils.getRootRect(i.rootMargin);let u=this.rootBounds,d=u[n],m=d/l[n],{enter:b,leave:p}=this._utils.getTriggerData(o),{hasEnteredFromOneSide:w,onScroll:{backup:E}}=this._utils.getTriggerStates(o),W=l[n]>=d,O=b>m,C=1-p>m,L=W&&(O||C),v=!!E,A=l[s]+b*l[n]<u[e]&&l[s]+b*l[n]>u[s],M=l[s]+p*l[n]<u[e]&&l[s]+p*l[n]>u[s],V=l[s]+b*l[n]<u[s],H=l[s]+p*l[n]>u[e],T=l[s]+p*l[n]<u[s]&&g<1-p,F=l[s]<u[s],I=l[e]<u[s];switch(!0){case this._states.oCbFirstInvoke:switch(!0){case(!h&&F&&I):this._utils.onTriggerEnter(o),this._utils.onTriggerLeave(o);break;case h:switch(!0){case(A||M||V&&H):this._utils.onTriggerEnter(o);break;case T:this._utils.onTriggerEnter(o),this._utils.onTriggerLeave(o);break}L&&this._utils.setTriggerScrollStates(o,"backup",this._utils.toggleActions);break}break;case!h:switch(v&&this._utils.setTriggerScrollStates(o,"backup",null),!0){case(w&&l[e]<u[s]):this._utils.onTriggerLeave(o);break;case(w&&l[s]>u[e]):this._utils.onTriggerLeave(o,"onLeaveBack");break}break;case(h&&!v):this._utils.toggleActions(o),L&&this._utils.setTriggerScrollStates(o,"backup",this._utils.toggleActions);break}}this._states.oCbFirstInvoke=!1};_setInstance(){this._defaultOptions=K,this._options=_(this._defaultOptions,this._userOptions),this.axis=c.string(this._options.axis)?this._options.axis:f("axis parameter must be a string."),this.name=c.string(this._options.name)?this._options.name:f("name parameter must be a string."),this._root=!!this._options.root&&this._utils.customParseQuery(this._options.root,"root")||null,this._positions=this._utils.parsePositions(this._options.enter,this._options.leave),this.customScrollHandler=this._options.onScroll;let{once:t,onEnter:i,onLeave:s,onEnterBack:e,onLeaveBack:n,toggleClass:a,animation:o}=this._options.defaults;return this._triggerParams={enter:this._positions.triggerEnterPosition.value,leave:this._positions.triggerLeavePosition.value,once:t,onEnter:i,onLeave:s,onEnterBack:e,onLeaveBack:n,toggleClass:a,animation:o},this._rootMargin=this._utils.setRootMargin(),this._createInstance(),this.customScrollHandler&&this.addScrollListener(this.customScrollHandler),this}add(t={},i={}){let s=this._utils.customParseQuery(t);"enter"in i&&(i.enter=this._utils.setPositionData(i.enter).value),"leave"in i&&(i.leave=this._utils.setPositionData(i.leave).value);let e={..._(this._triggerParams,i),states:{...X}};e.toggleClass&&(e.toggleClass=this._utils.parseToggleClass(e.toggleClass)),e.animation&&(e.animation=this._utils.parseAnimation(e.animation)),this.triggers=[...new Set([...this.triggers,...s])];let n=!1;return[i.enter,i.leave].forEach(a=>!this._threshold.some(o=>a===o)&&(n=!0)),n?(this._disconnect(),s.forEach(a=>this._utils.setTriggerData(a,e)),this._createInstance(),this.triggers.forEach(a=>this.observer.observe(a))):s.forEach(a=>{this._utils.setTriggerData(a,e),this.observer.observe(a)}),this._guidesInstance&&this._guidesInstance.refresh(),this}remove(t={}){let i=this._utils.customParseQuery(t);i.forEach(e=>{this._utils.deleteTriggerData(e),this.observer.unobserve(e)});let s=this.triggers.filter(e=>!i.some(a=>e===a));return this.triggers=s,this._guidesInstance&&this._guidesInstance.refresh(),this}_disconnect(){this.observer&&this.observer.disconnect(),this.observer=null}kill(){this._disconnect(),this.removeScrollListener(this.customScrollHandler),this.triggers=[],this.removeGuides();let t=k.indexOf(this);~t&&k.splice(t,1)}addGuides(t){return c.inObject(t,"_registerIntersectionTrigger")||f("Invalid Guides Instance."),t._registerIntersectionTrigger(this),t.refresh(),this._guidesInstance=t,this}removeGuides(){return this._guidesInstance&&this._guidesInstance.kill(),this._guidesInstance=null,this}update(){this._guidesInstance&&this._guidesInstance.refresh()}};P.getInstances=()=>k;P.getInstanceById=r=>k.find(t=>t.id===r);P.update=()=>k.forEach(r=>r.update());P.registerPlugins=(r=[])=>st.push(...r);P.getRegisteredPlugins=()=>st;export{P as default};
