/*
* IntersectionTrigger v1.0.0
* https://sunshine-themes.com/intersectionTrigger
*
* @license Copyright 2022, Sunshine. All rights reserved.
* Subject to the terms at https://sunshine-themes.com/intersectionTrigger/standard-licensew.
* @author: Sherif magdy, sherifmagdy@sunshine-themes.com
*/
                  
var b=()=>{};var B={defaults:{enter:"0%",leave:"100%",once:!1,onEnter:b,onLeave:b,onEnterBack:b,onLeaveBack:b,toggleClass:null,animation:null},rootEnter:"100%",rootLeave:"0%",axis:"y",name:"",root:null,onScroll:b},M={hasEntered:!1,hasEnteredBack:!1,hasLeft:!0,hasLeftBack:!0,hasEnteredOnce:!1,onScroll:{backup:null,animate:null},ids:{snapTimeOutId:0}};var c={function:i=>typeof i=="function",string:i=>typeof i=="string",boolean:i=>typeof i=="boolean",object:i=>i&&typeof i=="object"&&!(i instanceof Array),inObject:(i,t)=>c.object(i)&&t in i,num:i=>typeof i=="number",percent:i=>i&&i.includes("%"),pixel:i=>i&&i.includes("px"),array:i=>i instanceof Array,element:i=>i instanceof HTMLElement||i instanceof Element,doc:i=>i&&i.nodeType===9,scrollable:(i,t=null)=>t?t==="y"?i.scrollHeight>i.clientHeight:i.scrollWidth>i.clientWidth:i.scrollHeight>i.clientHeight||i.scrollWidth>i.clientWidth,anime:i=>c.object(i)&&i.hasOwnProperty("animatables")&&!i.hasOwnProperty("add"),tl:i=>c.object(i)&&i.hasOwnProperty("add")&&c.function(i.add),animeInstance:i=>c.anime(i)||c.tl(i)};var H=(i,t)=>i&&i.getBoundingClientRect()[t],A=(i,t)=>t==="y"?i.scrollHeight:i.scrollWidth,L=(i,t)=>{c.string(i)&&(i=parseFloat(i));let e=Math.pow(10,t||0);return Math.round(i*e)/e};var x=(i,t)=>{let e=i,s=t;return Object.entries(e).forEach(([r,o])=>{c.object(o)?x(o,s[r]=s[r]||{}):r in s||(s[r]=o)}),s},d=i=>{throw new Error(i)},R=(i,t)=>[i,t].sort((e,s)=>e-s),D=i=>{let t=/^(-?\d*\.?\d+)(px|%)$/.exec(i);return{value:parseFloat(t[1]),unit:t[2]}},F=i=>i.split(/\s+/).map(t=>D(t));var C=class{constructor(t){return this._it=t,this.setUtils(),this}setUtils(){this.isVirtical=()=>this._it.axis==="y",this.isViewport=()=>!this._it._root,this.getRoot=()=>this._it._root??window,this.dirProps=()=>this.isVirtical()?{ref:"top",length:"height",refOpposite:"bottom",clientLength:document.documentElement.clientHeight}:{ref:"left",length:"width",refOpposite:"right",clientLength:document.documentElement.clientWidth},this.setRootMargin=(t,e)=>{let{length:s,clientLength:r}=this.dirProps(),o=this._it._root?H(this._it._root,s):r,a=(h,g)=>{let{value:u,unit:p,normal:m}=h;if(p==="%")return m*g;if(p==="px")return u};t.pixeled=a(t,o),e.pixeled=a(e,o),this._it._isREPGreater=t.pixeled>=e.pixeled;let n={};n.fromOppRef=`${(this._it._isREPGreater?t.pixeled:e.pixeled)-o}px`,n.fromRef=`${-1*(this._it._isREPGreater?e.pixeled:t.pixeled)}px`;let l=A(this.isViewport()?document.body:this._it._root,this.isVirtical()?"x":"y");return this.isVirtical()?`${n.fromRef} ${l}px ${n.fromOppRef} ${l}px`:`${l}px ${n.fromOppRef} ${l}px ${n.fromRef}`},this.setThreshold=()=>{let{enter:t,leave:e,maxPosition:s}=this._it._defaultTriggerParams,r=[0,t,e,L(1-s,2),1];return this._it.triggers.forEach(o=>{let{enter:a,leave:n,maxPosition:l}=this.getTriggerData(o);r.push(a,n,L(1-l,2))}),[...new Set(r)]},this.parseQuery=(t,e)=>{switch(!0){case c.string(t):return[...document.querySelectorAll(t)];case c.array(t):return t;case c.element(t):return[t];default:d(`${e} parameter must be a valid selector, an element or array of elements`)}},this.customParseQuery=(t,e="trigger")=>{let s=e==="trigger",r=s?[]:{};return s?this.parseQuery(t,"trigger"):(r=c.string(t)?document.querySelector(t):c.element(t)?t:d("root parameter must be a valid selector or an element"),r)},this.validatePosition=t=>(c.function(t)&&(t=t(this._it)),c.string(t)||d("enter, leave, rootEnter and rootLeave parameters must be a string."),t),this.setPositionData=t=>{t=this.validatePosition(t);let e=t.trim(),s=D(e),r=L(s.value);return{original:e,unit:s.unit,value:r,normal:s.unit==="%"?r/100:null}},this.parsePositions=(t,e,s,r)=>{let o=[t,s,e,r].map(a=>this.setPositionData(this.validatePosition(a).trim()));return{tEP:o[0],rEP:o[1],tLP:o[2],rLP:o[3]}},this.deleteTriggerData=t=>{this._it._triggersData.delete(t)},this.hasTriggerData=(t,e=null)=>{let s=this._it._triggersData.has(t);return e?s&&e in this.getTriggerData(t):s},this.getTriggerData=(t,e=null)=>e?this.hasTriggerData(t,e)?this._it._triggersData.get(t)[e]:{}:this.hasTriggerData(t)&&this._it._triggersData.get(t)||{},this.setTriggerData=(t,e,s=null)=>{if(s){let r=this.getTriggerData(t);c.object(r)&&this._it._triggersData.set(t,{...r,...s});return}this._it._triggersData.set(t,e)},this.getTriggerStates=(t,e=null)=>{let s=this.getTriggerData(t,"states"),r=s.hasEntered||s.hasEnteredBack;return e?s[e]:{...s,hasEnteredFromOneSide:r}},this.setTriggerStates=(t,e={})=>{let s=this.getTriggerData(t),r=s&&{...s.states,...e};this.setTriggerData(t,null,{states:r})},this.setTriggerScrollStates=(t,e,s=null)=>{let r=this.getTriggerStates(t,"onScroll");if(r[e]=s,this.setTriggerStates(t,{onscroll:{...r}}),s){this._it._states.runningScrollCbs===0&&this._it.addScrollListener(this._it._onScrollHandler),this._it._states.runningScrollCbs++;return}0<this._it._states.runningScrollCbs&&this._it._states.runningScrollCbs--,this._it._states.runningScrollCbs===0&&this._it.removeScrollListener(this._it._onScrollHandler)},this.onTriggerEnter=(t,e="Enter")=>{let{hasEnteredOnce:s}=this.getTriggerStates(t),{onEnter:r,onEnterBack:o,toggleClass:a,animation:n}=this.getTriggerData(t),l=e==="Enter",h={callback:l?r:o,enterProp:l?"hasEntered":"hasEnteredBack",leaveProp:l?"hasLeftBack":"hasLeft",eventIndex:l?0:2};h.callback(t,this),this._it.toggleClass&&a&&this._it.toggleClass.toggle(t,a,h.eventIndex),this._it.animation&&n&&this._it.animation.animate(t,n,h.eventIndex);let g=s?{[h.enterProp]:!0,[h.leaveProp]:!1}:{[h.enterProp]:!0,hasLeft:!1,hasLeftBack:!1};this.setTriggerStates(t,g),s||this.setTriggerStates(t,{hasEnteredOnce:!0})},this.onTriggerLeave=(t,e="Leave")=>{let{once:s}=this.getTriggerData(t),{hasEnteredOnce:r}=this.getTriggerStates(t),{onLeave:o,onLeaveBack:a,toggleClass:n,animation:l}=this.getTriggerData(t),h=e==="Leave",g={callback:h?o:a,leaveProp:h?"hasLeft":"hasLeftBack",eventIndex:h?1:3};g.callback(t,this),this._it.toggleClass&&n&&this._it.toggleClass.toggle(t,n,g.eventIndex),this._it.animation&&l&&this._it.animation.animate(t,l,g.eventIndex),this.setTriggerStates(t,{[g.leaveProp]:!0,hasEntered:!1,hasEnteredBack:!1}),s&&r&&this._it.remove(t)},this.getPositions=(t,e,{enter:s,leave:r,ref:o,refOpposite:a,length:n})=>{let l=this._it._isREPGreater;return[t[o]+s*t[n],t[o]+r*t[n],l?e[a]:e[o],l?e[o]:e[a]]},this.toggleActions=t=>{let e=t.getBoundingClientRect();this._it.rootBounds=this.getRootRect(this._it.observer.rootMargin);let s=this._it.rootBounds,{hasEnteredFromOneSide:r,hasLeft:o,hasLeftBack:a,hasEnteredOnce:n}=this.getTriggerStates(t),{enter:l,leave:h}=this.getTriggerData(t),{ref:g,refOpposite:u,length:p}=this.dirProps(),[m,E,T,P]=this.getPositions(e,s,{enter:l,leave:h,ref:g,refOpposite:u,length:p}),v=!0;switch(!0){case(a&&T>m):this.onTriggerEnter(t);break;case(r&&P>E):this.onTriggerLeave(t);break;case(o&&n&&P<E):this.onTriggerEnter(t,"EnterBack");break;case(r&&T<m):this.onTriggerLeave(t,"hasLeftBack");break;default:v=!1;break}return v},this.parseRootMargin=t=>{var e=t||"0px",s=F(e);return s[1]=s[1]||s[0],s[2]=s[2]||s[0],s[3]=s[3]||s[1],s},this.expandRectByRootMargin=(t,e)=>{let s=this.parseRootMargin(e).map((o,a)=>o.unit=="px"?o.value:o.value*(a%2?t.width:t.height)/100),r={top:t.top-s[0],right:t.right+s[1],bottom:t.bottom+s[2],left:t.left-s[3]};return r.width=r.right-r.left,r.height=r.bottom-r.top,r},this.getRootRect=t=>{let e;if(this._it._root&&!c.doc(this._it._root))return e=this._it._root.getBoundingClientRect(),this.expandRectByRootMargin(e,t);let s=c.doc(this._it._root)?this._it._root:document,r=s.documentElement,o=s.body;return e={top:0,left:0,right:r.clientWidth||o.clientWidth,width:r.clientWidth||o.clientWidth,bottom:r.clientHeight||o.clientHeight,height:r.clientHeight||o.clientHeight},this.expandRectByRootMargin(e,t)}}},V=C;var z=[],f=[],$=0,_=class{constructor(t={}){this._userOptions=t,this.triggers=[],this._triggersData=new WeakMap,this._guidesInstance=null,this._utils=new V(this),this.id=$,$++,f.push(this),this.animation=null,this.toggleClass=null,this._setStates(),this._setPlugins(),this._setInstance()}_setPlugins(){_.getRegisteredPlugins().forEach(e=>{switch(e.name){case"Animation":this.animation=new e(this);break;case"ToggleClass":this.toggleClass=new e(this);break}})}_addResizeListener(){this._removeResizeListener(),this._onResizeHandler=()=>this.update(),this._utils.getRoot().addEventListener("resize",this._onResizeHandler,!1)}_removeResizeListener(){this._utils.getRoot().removeEventListener("resize",this._onResizeHandler,!1)}_setStates(){this._states={},this._states.oCbFirstInvoke=!0,this._states.runningScrollCbs=0}_rAFCallback=t=>{this.triggers.forEach(e=>{let s=this._utils.getTriggerStates(e,"onScroll");for(let r in s)s[r]&&c.function(s[r])&&s[r](e,t)})};_onScrollHandler=()=>requestAnimationFrame(this._rAFCallback);addScrollListener(t){this._utils.getRoot().addEventListener("scroll",t,!1)}removeScrollListener(t){this._utils.getRoot().removeEventListener("scroll",t,!1)}_observerCallback=(t,e)=>{let{ref:s,refOpposite:r,length:o}=this._utils.dirProps();for(let a of t){let n=a.target,l=a.boundingClientRect,h=a.isIntersecting;this.rootBounds=a.rootBounds||this._utils.getRootRect(e.rootMargin);let g=this.rootBounds,u=g[o],p=u/l[o],{enter:m,leave:E,minPosition:T,maxPosition:P}=this._utils.getTriggerData(n),{hasEnteredFromOneSide:v,onScroll:{backup:W}}=this._utils.getTriggerStates(n),[I,S,O,k]=this._utils.getPositions(l,g,{enter:m,leave:E,ref:s,refOpposite:r,length:o}),w=l[o]>=u&&(T>=p||1-P>=p),y=!!W;switch(!0){case this._states.oCbFirstInvoke:switch(!0){case(!h&&k>S):this._utils.onTriggerEnter(n),this._utils.onTriggerLeave(n);break;case h:switch(!0){case(O>I&&k<S):this._utils.onTriggerEnter(n);break;case k>S:this._utils.onTriggerEnter(n),this._utils.onTriggerLeave(n);break}w&&this._utils.setTriggerScrollStates(n,"backup",this._utils.toggleActions);break}break;case!h:switch(y&&this._utils.setTriggerScrollStates(n,"backup",null),!0){case(v&&k>S):this._utils.onTriggerLeave(n);break;case(v&&O<I):this._utils.onTriggerLeave(n,"onLeaveBack");break}break;case(h&&!y):this._utils.toggleActions(n),w&&this._utils.setTriggerScrollStates(n,"backup",this._utils.toggleActions);break}}this._states.oCbFirstInvoke=!1};_createInstance(){this._rootMargin=this._utils.setRootMargin(this._positionsData.rEP,this._positionsData.rLP),this._threshold=this._utils.setThreshold(),this._observerOptions={root:this._root,rootMargin:this._rootMargin,threshold:this._threshold},this.observer=new IntersectionObserver(this._observerCallback,this._observerOptions),this._root=this.observer.root,this.rootBounds=this._utils.getRootRect(this.observer.rootMargin),this._isViewport=this._utils.isViewport()}_setInstance(){this._defaultOptions=B,this._options=x(this._defaultOptions,this._userOptions),this.axis=c.string(this._options.axis)?this._options.axis:d("axis parameter must be a string."),this.name=c.string(this._options.name)?this._options.name:d("name parameter must be a string."),this._root=!!this._options.root&&this._utils.customParseQuery(this._options.root,"root")||null,this._positionsData=this._utils.parsePositions(this._options.defaults.enter,this._options.defaults.leave,this._options.rootEnter,this._options.rootLeave),this.customScrollHandler=this._options.onScroll;let{once:t,onEnter:e,onLeave:s,onEnterBack:r,onLeaveBack:o,toggleClass:a,animation:n}=this._options.defaults,l=this._positionsData.tEP.normal,h=this._positionsData.tLP.normal,[g,u]=R(l,h);return this._defaultTriggerParams={enter:l,leave:h,minPosition:g,maxPosition:u,once:t,onEnter:e,onLeave:s,onEnterBack:r,onLeaveBack:o,toggleClass:a,animation:n},this._createInstance(),this._addResizeListener(),this.customScrollHandler&&this.addScrollListener(this.customScrollHandler),this}add(t={},e={}){let s=this._utils.customParseQuery(t);"enter"in e&&(e.enter=this._utils.setPositionData(e.enter).normal),"leave"in e&&(e.leave=this._utils.setPositionData(e.leave).normal);let r=x(this._defaultTriggerParams,e),[o,a]=R(r.enter,r.leave),n={...r,minPosition:o,maxPosition:a,states:{...M}};this.toggleClass&&n.toggleClass&&(n.toggleClass=this.toggleClass.parse(n.toggleClass)),this.animation&&n.animation&&(n.animation=this.animation.parse(n.animation)),this.triggers=[...new Set([...this.triggers,...s])];let l=!1;return[e.enter,e.leave].forEach(h=>!this._threshold.some(g=>h===g)&&(l=!0)),l?this.update(s,n):s.forEach(h=>{this._utils.setTriggerData(h,n),this.observer.observe(h)}),this._guidesInstance&&this._guidesInstance.update(),this}remove(t={}){let e=this._utils.customParseQuery(t);e.forEach(r=>{this._utils.deleteTriggerData(r),this.observer.unobserve(r)});let s=this.triggers.filter(r=>!e.some(a=>r===a));return this.triggers=s,this._guidesInstance&&this._guidesInstance.update(),this}_disconnect(){this.observer&&this.observer.disconnect(),this.observer=null}kill(){this._disconnect(),this.removeScrollListener(this.customScrollHandler),this._removeResizeListener(),this.triggers=[],this.removeGuides(),this.animation&&this.animation.kill(),this.toggleClasss&&this.toggleClasss.kill();let t=f.indexOf(this);~t&&f.splice(t,1)}addGuides(t){return c.inObject(t,"_registerIntersectionTrigger")||d("Invalid Guides Instance."),t._registerIntersectionTrigger(this),t.update(),this._guidesInstance=t,this}removeGuides(){return this._guidesInstance&&this._guidesInstance.kill(),this._guidesInstance=null,this}update(t=null,e=null){this._disconnect(),t&&t.forEach(s=>this._utils.setTriggerData(s,e)),this._createInstance(),this.triggers.forEach(s=>this.observer.observe(s)),this._guidesInstance&&this._guidesInstance.update()}};_.getInstances=()=>f;_.getInstanceById=i=>f.find(t=>t.id===i);_.update=()=>f.forEach(i=>i.update());_.registerPlugins=(i=[])=>z.push(...i);_.getRegisteredPlugins=()=>z;export{_ as default};
